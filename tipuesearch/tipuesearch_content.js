var tipuesearch = {"pages":[{"title":" HoneyTools ","text":"HoneyTools Honeycomb flakes, sheets, ribbons, whatever. Made easy. API documentation. For examples of usage see the project wiki . General info can be found on the repository frontpage . Developer Info Gabriele Bellomia Ph.D. student at SISSA","tags":"home","loc":"index.html"},{"title":"hex_orientation – HoneyTools ","text":"type, public :: hex_orientation lattice-orientation data storage Inherited by type~~hex_orientation~~InheritedByGraph type~hex_orientation hex_orientation type~unit_cell unit_cell type~unit_cell->type~hex_orientation orientation Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables uq ur angle Type-Bound Procedures operator(==) orientation_equality Components Type Visibility Attributes Name Initial real(kind=8), public, dimension(2) :: uq 1st unit-vector real(kind=8), public, dimension(2) :: ur 2nd unit-vector real(kind=8), public :: angle in units of 60° Type-Bound Procedures generic, public,  :: operator(==) => orientation_equality private pure function orientation_equality (a, b) result(isequal) Overload of == operator for hex_orientation type Arguments Type Intent Optional Attributes Name class( hex_orientation ), intent(in) :: a class( hex_orientation ), intent(in) :: b Return Value logical procedure, private :: orientation_equality private pure function orientation_equality (a, b) result(isequal) Overload of == operator for hex_orientation type Arguments Type Intent Optional Attributes Name class( hex_orientation ), intent(in) :: a class( hex_orientation ), intent(in) :: b Return Value logical","tags":"","loc":"type/hex_orientation.html"},{"title":"unit_cell – HoneyTools ","text":"type, public :: unit_cell Wrapper type to define all about a honeycomb structure Inherits type~~unit_cell~~InheritsGraph type~unit_cell unit_cell type~hex_orientation hex_orientation type~unit_cell->type~hex_orientation orientation Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables orientation size origin Type-Bound Procedures print Components Type Visibility Attributes Name Initial type( hex_orientation ), public :: orientation armchair or zigzag real(kind=8), public :: size = 1d0 lattice parameter real(kind=8), public, dimension(2) :: origin = [0d0, 0d0] Type-Bound Procedures procedure, public,  :: print => print_unit_cell call layout%print public impure elemental subroutine print_unit_cell (C, unit) Pretty print of hex coordinates Arguments Type Intent Optional Attributes Name class( unit_cell ), intent(in) :: C integer, intent(in), optional :: unit default = $stdout","tags":"","loc":"type/unit_cell.html"},{"title":"hex – HoneyTools ","text":"type, public :: hex cubic coordinates for hexagonal tiles Contents Variables q r s Constructor hex Components Type Visibility Attributes Name Initial integer, public :: q constrained by q+r+s==0 integer, public :: r constrained by q+r+s==0 integer, public :: s constrained by q+r+s==0 Constructor public        interface hex constructor override private pure function new_hex_cubic (q, r, s) result(H) Safe cubic constructor for the hex type\nfeaturing an assertion on input coordinates\nbefore the initialization of the object Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r integer, intent(in) :: s Return Value type( hex ) private pure function new_hex_axial (q, r) result(H) Axial cubic constructor for the hex type\n[s would be computed internally] Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r Return Value type( hex )","tags":"","loc":"type/hex.html"},{"title":"xy – HoneyTools ","text":"type, public :: xy Base type for 2D points Inherited by type~~xy~~InheritedByGraph type~xy xy type~xy_site xy_site type~xy_site->type~xy type~xy_lattice xy_lattice type~xy_lattice->type~xy_site site Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables x y Type-Bound Procedures operator(==) operator(/=) eq_xy neq_xy Components Type Visibility Attributes Name Initial real(kind=8), public :: x real(kind=8), public :: y Type-Bound Procedures generic, public,  :: operator(==) => eq_xy private pure elemental function eq_xy (A, B) result(isequal) tolerance equality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical generic, public,  :: operator(/=) => neq_xy private pure elemental function neq_xy (A, B) result(notequal) tolerance inequality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical procedure, private :: eq_xy private pure elemental function eq_xy (A, B) result(isequal) tolerance equality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical procedure, private :: neq_xy private pure elemental function neq_xy (A, B) result(notequal) tolerance inequality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical","tags":"","loc":"type/xy.html"},{"title":"xy_site – HoneyTools ","text":"type, public, extends( xy ) :: xy_site A 2D point extension for inequivalent sites Inherits type~~xy_site~~InheritsGraph type~xy_site xy_site type~xy xy type~xy_site->type~xy Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~xy_site~~InheritedByGraph type~xy_site xy_site type~xy_lattice xy_lattice type~xy_lattice->type~xy_site site Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables x y label key Type-Bound Procedures operator(==) operator(/=) Components Type Visibility Attributes Name Initial real(kind=8), public :: x real(kind=8), public :: y character(len=1), public :: label A or B (sublattice) integer, public :: key = 0 for lattice lookup Type-Bound Procedures generic, public,  :: operator(==) => eq_xy private pure elemental function eq_xy (A, B) result(isequal) tolerance equality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical generic, public,  :: operator(/=) => neq_xy private pure elemental function neq_xy (A, B) result(notequal) tolerance inequality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical","tags":"","loc":"type/xy_site.html"},{"title":"xy_lattice – HoneyTools ","text":"type, public :: xy_lattice Wrapper type for storing dynamically\nsized collections of lattice sites Inherits type~~xy_lattice~~InheritsGraph type~xy_lattice xy_lattice type~xy_site xy_site type~xy_lattice->type~xy_site site type~xy xy type~xy_site->type~xy Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Contents Variables site size Type-Bound Procedures operator(==) operator(/=) push_back eq_lattice neq_lattice Components Type Visibility Attributes Name Initial type( xy_site ), public, allocatable :: site (:) integer, public :: size Type-Bound Procedures generic, public,  :: operator(==) => eq_lattice private pure elemental function eq_lattice (A, B) result(isequal) polymorphic equality overload for xy_lattice type Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(in) :: A class( xy_lattice ), intent(in) :: B Return Value logical generic, public,  :: operator(/=) => neq_lattice private pure elemental function neq_lattice (A, B) result(notequal) polymorphic inequality overload for xy_lattice type Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(in) :: A class( xy_lattice ), intent(in) :: B Return Value logical procedure, public,  :: push_back private pure subroutine push_back (vec, val) Poor man implementation of a dynamic\narray, a là std::vector (but without\npreallocation and smart doubling...) Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(inout) :: vec type( xy_site ), intent(in) :: val procedure, private :: eq_lattice private pure elemental function eq_lattice (A, B) result(isequal) polymorphic equality overload for xy_lattice type Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(in) :: A class( xy_lattice ), intent(in) :: B Return Value logical procedure, private :: neq_lattice private pure elemental function neq_lattice (A, B) result(notequal) polymorphic inequality overload for xy_lattice type Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(in) :: A class( xy_lattice ), intent(in) :: B Return Value logical","tags":"","loc":"type/xy_lattice.html"},{"title":"orientation_equality – HoneyTools","text":"private pure function orientation_equality(a, b) result(isequal) Overload of == operator for hex_orientation type Type Bound hex_orientation Arguments Type Intent Optional Attributes Name class( hex_orientation ), intent(in) :: a class( hex_orientation ), intent(in) :: b Return Value logical Contents","tags":"","loc":"proc/orientation_equality.html"},{"title":"print_unit_cell – HoneyTools","text":"public impure elemental subroutine print_unit_cell(C, unit) Pretty print of hex coordinates Type Bound unit_cell Arguments Type Intent Optional Attributes Name class( unit_cell ), intent(in) :: C integer, intent(in), optional :: unit default = $stdout Calls proc~~print_unit_cell~~CallsGraph proc~print_unit_cell hex_layout::unit_cell%print_unit_cell origin origin proc~print_unit_cell->origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/print_unit_cell.html"},{"title":"hex_norm – HoneyTools","text":"public pure function hex_norm(H) result(n) Taxicab norm from hex coordinates Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: H Return Value integer Called by proc~~hex_norm~~CalledByGraph proc~hex_norm hex_coordinates::hex_norm proc~hex_distance hex_coordinates::hex_distance proc~hex_distance->proc~hex_norm proc~hex_line hex_geometries::hex_line proc~hex_line->proc~hex_distance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex_norm.html"},{"title":"hex_distance – HoneyTools","text":"public pure function hex_distance(A, B) result(d) Taxicab distance of hex coordinates Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value integer Calls proc~~hex_distance~~CallsGraph proc~hex_distance hex_coordinates::hex_distance proc~hex_norm hex_coordinates::hex_norm proc~hex_distance->proc~hex_norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex_distance~~CalledByGraph proc~hex_distance hex_coordinates::hex_distance proc~hex_line hex_geometries::hex_line proc~hex_line->proc~hex_distance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex_distance.html"},{"title":"new_hex_cubic – HoneyTools","text":"private pure function new_hex_cubic(q, r, s) result(H) Safe cubic constructor for the hex type\nfeaturing an assertion on input coordinates\nbefore the initialization of the object Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r integer, intent(in) :: s Return Value type( hex ) Calls proc~~new_hex_cubic~~CallsGraph proc~new_hex_cubic hex_coordinates::new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~new_hex_cubic~~CalledByGraph proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex hex_coordinates::hex interface~hex->proc~new_hex_cubic proc~add_hex hex_coordinates::add_hex proc~add_hex->interface~hex proc~lhs_hex hex_coordinates::lhs_hex proc~lhs_hex->interface~hex proc~rhs_hex hex_coordinates::rhs_hex proc~rhs_hex->interface~hex proc~sub_hex hex_coordinates::sub_hex proc~sub_hex->interface~hex interface~operator(+) hex_coordinates::operator(+) interface~operator(+)->proc~add_hex interface~operator(-) hex_coordinates::operator(-) interface~operator(-)->proc~sub_hex interface~operator(ASTERISK) hex_coordinates::operator(*) interface~operator(ASTERISK)->proc~lhs_hex interface~operator(ASTERISK)->proc~rhs_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/new_hex_cubic.html"},{"title":"new_hex_axial – HoneyTools","text":"private pure function new_hex_axial(q, r) result(H) Axial cubic constructor for the hex type\n[s would be computed internally] Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r Return Value type( hex ) Called by proc~~new_hex_axial~~CalledByGraph proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex hex_coordinates::hex interface~hex->proc~new_hex_axial proc~add_hex hex_coordinates::add_hex proc~add_hex->interface~hex proc~lhs_hex hex_coordinates::lhs_hex proc~lhs_hex->interface~hex proc~rhs_hex hex_coordinates::rhs_hex proc~rhs_hex->interface~hex proc~sub_hex hex_coordinates::sub_hex proc~sub_hex->interface~hex interface~operator(+) hex_coordinates::operator(+) interface~operator(+)->proc~add_hex interface~operator(-) hex_coordinates::operator(-) interface~operator(-)->proc~sub_hex interface~operator(ASTERISK) hex_coordinates::operator(*) interface~operator(ASTERISK)->proc~lhs_hex interface~operator(ASTERISK)->proc~rhs_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/new_hex_axial.html"},{"title":"eq_hex – HoneyTools","text":"private pure elemental function eq_hex(A, B) result(isequal) Equality overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value logical Called by proc~~eq_hex~~CalledByGraph proc~eq_hex hex_coordinates::eq_hex interface~operator(==) hex_coordinates::operator(==) interface~operator(==)->proc~eq_hex proc~neq_hex hex_coordinates::neq_hex proc~neq_hex->proc~eq_hex interface~operator(SLASH=) hex_coordinates::operator(/=) interface~operator(SLASH=)->proc~neq_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/eq_hex.html"},{"title":"neq_hex – HoneyTools","text":"private pure elemental function neq_hex(A, B) result(notequal) Inequality overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value logical Calls proc~~neq_hex~~CallsGraph proc~neq_hex hex_coordinates::neq_hex proc~eq_hex hex_coordinates::eq_hex proc~neq_hex->proc~eq_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~neq_hex~~CalledByGraph proc~neq_hex hex_coordinates::neq_hex interface~operator(SLASH=) hex_coordinates::operator(/=) interface~operator(SLASH=)->proc~neq_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/neq_hex.html"},{"title":"add_hex – HoneyTools","text":"private pure elemental function add_hex(A, B) result(C) Addition overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex ) Calls proc~~add_hex~~CallsGraph proc~add_hex hex_coordinates::add_hex interface~hex hex_coordinates::hex proc~add_hex->interface~hex proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex->proc~new_hex_axial proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex->proc~new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_hex~~CalledByGraph proc~add_hex hex_coordinates::add_hex interface~operator(+) hex_coordinates::operator(+) interface~operator(+)->proc~add_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/add_hex.html"},{"title":"sub_hex – HoneyTools","text":"private pure elemental function sub_hex(A, B) result(C) Subtraction overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex ) Calls proc~~sub_hex~~CallsGraph proc~sub_hex hex_coordinates::sub_hex interface~hex hex_coordinates::hex proc~sub_hex->interface~hex proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex->proc~new_hex_axial proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex->proc~new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sub_hex~~CalledByGraph proc~sub_hex hex_coordinates::sub_hex interface~operator(-) hex_coordinates::operator(-) interface~operator(-)->proc~sub_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/sub_hex.html"},{"title":"rhs_hex – HoneyTools","text":"private pure elemental function rhs_hex(A, k) result(C) Right scale overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A integer, intent(in) :: k Return Value type( hex ) Calls proc~~rhs_hex~~CallsGraph proc~rhs_hex hex_coordinates::rhs_hex interface~hex hex_coordinates::hex proc~rhs_hex->interface~hex proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex->proc~new_hex_axial proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex->proc~new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~rhs_hex~~CalledByGraph proc~rhs_hex hex_coordinates::rhs_hex interface~operator(ASTERISK) hex_coordinates::operator(*) interface~operator(ASTERISK)->proc~rhs_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/rhs_hex.html"},{"title":"lhs_hex – HoneyTools","text":"private pure elemental function lhs_hex(k, B) result(C) Left scale overload for hex type Arguments Type Intent Optional Attributes Name integer, intent(in) :: k type( hex ), intent(in) :: B Return Value type( hex ) Calls proc~~lhs_hex~~CallsGraph proc~lhs_hex hex_coordinates::lhs_hex interface~hex hex_coordinates::hex proc~lhs_hex->interface~hex proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex->proc~new_hex_axial proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex->proc~new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lhs_hex~~CalledByGraph proc~lhs_hex hex_coordinates::lhs_hex interface~operator(ASTERISK) hex_coordinates::operator(*) interface~operator(ASTERISK)->proc~lhs_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/lhs_hex.html"},{"title":"dot_hex – HoneyTools","text":"private pure elemental function dot_hex(A, B) result(C) Dot overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value integer Called by proc~~dot_hex~~CalledByGraph proc~dot_hex hex_coordinates::dot_hex interface~operator(ASTERISK) hex_coordinates::operator(*) interface~operator(ASTERISK)->proc~dot_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/dot_hex.html"},{"title":"hex_print – HoneyTools","text":"public impure elemental subroutine hex_print(H, unit, quiet) Pretty print of hex coordinates Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: H integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false. Contents","tags":"","loc":"proc/hex_print.html"},{"title":"hex – HoneyTools","text":"public interface hex constructor override Calls interface~~hex~~CallsGraph interface~hex hex_coordinates::hex proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex->proc~new_hex_axial proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex->proc~new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~hex~~CalledByGraph interface~hex hex_coordinates::hex proc~add_hex hex_coordinates::add_hex proc~add_hex->interface~hex proc~lhs_hex hex_coordinates::lhs_hex proc~lhs_hex->interface~hex proc~rhs_hex hex_coordinates::rhs_hex proc~rhs_hex->interface~hex proc~sub_hex hex_coordinates::sub_hex proc~sub_hex->interface~hex interface~operator(+) hex_coordinates::operator(+) interface~operator(+)->proc~add_hex interface~operator(-) hex_coordinates::operator(-) interface~operator(-)->proc~sub_hex interface~operator(ASTERISK) hex_coordinates::operator(*) interface~operator(ASTERISK)->proc~lhs_hex interface~operator(ASTERISK)->proc~rhs_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures new_hex_cubic new_hex_axial Module Procedures private pure function new_hex_cubic (q, r, s) result(H) Safe cubic constructor for the hex type\nfeaturing an assertion on input coordinates\nbefore the initialization of the object Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r integer, intent(in) :: s Return Value type( hex ) private pure function new_hex_axial (q, r) result(H) Axial cubic constructor for the hex type\n[s would be computed internally] Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r Return Value type( hex )","tags":"","loc":"interface/hex.html"},{"title":"operator(==) – HoneyTools","text":"public interface operator(==) equality overload Calls interface~~operator(==)~~CallsGraph interface~operator(==) hex_coordinates::operator(==) proc~eq_hex hex_coordinates::eq_hex interface~operator(==)->proc~eq_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures eq_hex Module Procedures private pure elemental function eq_hex (A, B) result(isequal) Equality overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value logical","tags":"","loc":"interface/operator(==).html"},{"title":"operator(/=) – HoneyTools","text":"public interface operator(/=) inequality overload Calls interface~~operator(SLASH=)~~CallsGraph interface~operator(SLASH=) hex_coordinates::operator(/=) proc~neq_hex hex_coordinates::neq_hex interface~operator(SLASH=)->proc~neq_hex proc~eq_hex hex_coordinates::eq_hex proc~neq_hex->proc~eq_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures neq_hex Module Procedures private pure elemental function neq_hex (A, B) result(notequal) Inequality overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value logical","tags":"","loc":"interface/operator(SLASH=).html"},{"title":"operator(+) – HoneyTools","text":"public interface operator(+) addition overload Calls interface~~operator(+)~~CallsGraph interface~operator(+) hex_coordinates::operator(+) proc~add_hex hex_coordinates::add_hex interface~operator(+)->proc~add_hex interface~hex hex_coordinates::hex proc~add_hex->interface~hex proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex->proc~new_hex_axial proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex->proc~new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures add_hex Module Procedures private pure elemental function add_hex (A, B) result(C) Addition overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex )","tags":"","loc":"interface/operator(+).html"},{"title":"operator(-) – HoneyTools","text":"public interface operator(-) subtraction overload Calls interface~~operator(-)~~CallsGraph interface~operator(-) hex_coordinates::operator(-) proc~sub_hex hex_coordinates::sub_hex interface~operator(-)->proc~sub_hex interface~hex hex_coordinates::hex proc~sub_hex->interface~hex proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex->proc~new_hex_axial proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex->proc~new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures sub_hex Module Procedures private pure elemental function sub_hex (A, B) result(C) Subtraction overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex )","tags":"","loc":"interface/operator(-).html"},{"title":"operator(*) – HoneyTools","text":"public interface operator(*) product overload Calls interface~~operator(ASTERISK)~~CallsGraph interface~operator(ASTERISK) hex_coordinates::operator(*) proc~dot_hex hex_coordinates::dot_hex interface~operator(ASTERISK)->proc~dot_hex proc~lhs_hex hex_coordinates::lhs_hex interface~operator(ASTERISK)->proc~lhs_hex proc~rhs_hex hex_coordinates::rhs_hex interface~operator(ASTERISK)->proc~rhs_hex interface~hex hex_coordinates::hex proc~lhs_hex->interface~hex proc~rhs_hex->interface~hex proc~new_hex_axial hex_coordinates::new_hex_axial interface~hex->proc~new_hex_axial proc~new_hex_cubic hex_coordinates::new_hex_cubic interface~hex->proc~new_hex_cubic assert assert proc~new_hex_cubic->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures rhs_hex lhs_hex dot_hex Module Procedures private pure elemental function rhs_hex (A, k) result(C) Right scale overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A integer, intent(in) :: k Return Value type( hex ) private pure elemental function lhs_hex (k, B) result(C) Left scale overload for hex type Arguments Type Intent Optional Attributes Name integer, intent(in) :: k type( hex ), intent(in) :: B Return Value type( hex ) private pure elemental function dot_hex (A, B) result(C) Dot overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value integer","tags":"","loc":"interface/operator(ASTERISK).html"},{"title":"xy_nn_hop – HoneyTools","text":"public pure function xy_nn_hop(layout, S, i) result(Ni) Return the nearest neighbor of a lattice site, by hopping in\nthe i-th direction. You can feed any i ∈ ℤ, but you can get\nonly 3 inequivalent neighbors, depending on the label of the\ngiven site: \"A\" and \"B\" activate two different suitable sets\nof hopping directions. A lattice layout is required to build\nthe concrete hopping vectors. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( xy_site ), intent(in) :: S integer, intent(in) :: i Return Value type( xy_site ) Calls proc~~xy_nn_hop~~CallsGraph proc~xy_nn_hop xy_neighbors::xy_nn_hop proc~ith_a_offset xy_neighbors::ith_A_offset proc~xy_nn_hop->proc~ith_a_offset proc~ith_b_offset xy_neighbors::ith_B_offset proc~xy_nn_hop->proc~ith_b_offset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~xy_nn_hop~~CalledByGraph proc~xy_nn_hop xy_neighbors::xy_nn_hop proc~xy_nnn_hop xy_neighbors::xy_nnn_hop proc~xy_nnn_hop->proc~xy_nn_hop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_nn_hop.html"},{"title":"xy_nnn_hop – HoneyTools","text":"public pure function xy_nnn_hop(layout, S, i) result(Ni) Return the i-th next-nearest neighbor of a lattice site, by\ntaking two xy_nn_hops in the suitable direction.\nYou can feed any i ∈ ℤ, but you can get only 6 inequivalent\nneighbors, depending on the label of the given site:\n\"A\" and \"B\" activate two different suitable sets of NN hops,\nA lattice layout is required to build the concrete hoppings. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( xy_site ), intent(in) :: S integer, intent(in) :: i Return Value type( xy_site ) Calls proc~~xy_nnn_hop~~CallsGraph proc~xy_nnn_hop xy_neighbors::xy_nnn_hop proc~xy_nn_hop xy_neighbors::xy_nn_hop proc~xy_nnn_hop->proc~xy_nn_hop proc~ith_a_offset xy_neighbors::ith_A_offset proc~xy_nn_hop->proc~ith_a_offset proc~ith_b_offset xy_neighbors::ith_B_offset proc~xy_nn_hop->proc~ith_b_offset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_nnn_hop.html"},{"title":"ith_A_offset – HoneyTools","text":"private pure function ith_A_offset(layout, i) result(offset) Compute the offset vector connecting a site with label \"A\",\nto its i-th neighbor, returning a (scalar) xy coordinate.\nIt takes any i ∈ ℤ, but there will only be 3 inequivalent\noutput vectors, pointing to the three nearest neighbors. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout integer, intent(in) :: i Return Value type( xy ) Called by proc~~ith_a_offset~~CalledByGraph proc~ith_a_offset xy_neighbors::ith_A_offset proc~xy_nn_hop xy_neighbors::xy_nn_hop proc~xy_nn_hop->proc~ith_a_offset proc~xy_nnn_hop xy_neighbors::xy_nnn_hop proc~xy_nnn_hop->proc~xy_nn_hop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/ith_a_offset.html"},{"title":"ith_B_offset – HoneyTools","text":"private pure function ith_B_offset(layout, i) result(offset) Compute the offset vector connecting a site with label \"B\",\nto its i-th neighbor, returning a (scalar) xy coordinate.\nIt takes any i ∈ ℤ, but there will only be 3 inequivalent\noutput vectors, pointing to the three nearest neighbors. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout integer, intent(in) :: i Return Value type( xy ) Called by proc~~ith_b_offset~~CalledByGraph proc~ith_b_offset xy_neighbors::ith_B_offset proc~xy_nn_hop xy_neighbors::xy_nn_hop proc~xy_nn_hop->proc~ith_b_offset proc~xy_nnn_hop xy_neighbors::xy_nnn_hop proc~xy_nnn_hop->proc~xy_nn_hop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/ith_b_offset.html"},{"title":"xy_nearest_neighbors – HoneyTools","text":"public pure subroutine xy_nearest_neighbors(lattice, nn_mask) Build a mask for the nearest neighbors of a given\nlattice. It is a NxN matrix, with N the number of\nsites in the lattice, stocking .true. values only\nfor the pairs of sites linked by a \"NN-bond\".\nIt calls internally xy_shells, for all inter-site\ndistances, so if you need more than NNs consider\ncalling xy_shells directly. Note that we provide\na similar subroutine for next-nearest-neighbors,\nwhich optionally gives also the NNs, so if just\ntwo shells are needed you should call that. xy_next_nearest_neighbors(lattice,nnn,[nn]) Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice logical, intent(out), allocatable :: nn_mask (:,:) Calls proc~~xy_nearest_neighbors~~CallsGraph proc~xy_nearest_neighbors xy_neighbors::xy_nearest_neighbors proc~xy_shells xy_neighbors::xy_shells proc~xy_nearest_neighbors->proc~xy_shells proc~xy_distance xy_coordinates::xy_distance proc~xy_shells->proc~xy_distance site site proc~xy_shells->site sort sort proc~xy_shells->sort proc~xy_norm xy_coordinates::xy_norm proc~xy_distance->proc~xy_norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_nearest_neighbors.html"},{"title":"xy_next_nearest_neighbors – HoneyTools","text":"public pure subroutine xy_next_nearest_neighbors(lattice, nnn_mask, nn_mask) Build a mask for the next-nearest neighbors of a given lattice.\nIt is a NxN matrix, with N the number of sites in the lattice,\nstoring .true. values only for the pairs of sites linked by a\n\"NNN-bond\". Optionally builds a nearest-neighbors mask, too.\nIt calls internally xy_shells, for all inter-site\ndistances, so if you need more than NNNs consider\ncalling xy_shells directly. Note that we provide\na similar subroutine for nearest-neighbors only,\nso if you just need NNs consider calling it. call xy_nearest_neighbors(lattices,nn_maks) Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice logical, intent(out), allocatable :: nnn_mask (:,:) logical, intent(out), optional, allocatable :: nn_mask (:,:) Calls proc~~xy_next_nearest_neighbors~~CallsGraph proc~xy_next_nearest_neighbors xy_neighbors::xy_next_nearest_neighbors proc~xy_shells xy_neighbors::xy_shells proc~xy_next_nearest_neighbors->proc~xy_shells proc~xy_distance xy_coordinates::xy_distance proc~xy_shells->proc~xy_distance site site proc~xy_shells->site sort sort proc~xy_shells->sort proc~xy_norm xy_coordinates::xy_norm proc~xy_distance->proc~xy_norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_next_nearest_neighbors.html"},{"title":"xy_shells – HoneyTools","text":"public pure subroutine xy_shells(lattice, shell_table, distance_set) Build a /ordered/ set of all inter-atomic distances\nin a given xy_lattice and a table storing distances\namong all sites. Searching this matrix for the n-th\nset entry gives a mask of all pairs of atomic sites\nthat are n-th order neigbors.\nE.g. shell_table == distance_set(1) would provide a\nmask for nearest neighbors, from which we can build\nthe tight-binding hopping term of the corresponding\nlattice hamiltonian. Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice real(kind=8), intent(out), allocatable :: shell_table (:,:) real(kind=8), intent(out), allocatable :: distance_set (:) Calls proc~~xy_shells~~CallsGraph proc~xy_shells xy_neighbors::xy_shells proc~xy_distance xy_coordinates::xy_distance proc~xy_shells->proc~xy_distance site site proc~xy_shells->site sort sort proc~xy_shells->sort proc~xy_norm xy_coordinates::xy_norm proc~xy_distance->proc~xy_norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~xy_shells~~CalledByGraph proc~xy_shells xy_neighbors::xy_shells proc~xy_nearest_neighbors xy_neighbors::xy_nearest_neighbors proc~xy_nearest_neighbors->proc~xy_shells proc~xy_next_nearest_neighbors xy_neighbors::xy_next_nearest_neighbors proc~xy_next_nearest_neighbors->proc~xy_shells Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code xy_shells Source Code pure subroutine xy_shells ( lattice , shell_table , distance_set ) !! Build a /ordered/ set of all inter-atomic distances !! in a given xy_lattice and a table storing distances !! among all sites. Searching this matrix for the n-th !! set entry gives a mask of all pairs of atomic sites !! that are n-th order neigbors. !! E.g. shell_table == distance_set(1) would provide a !! mask for nearest neighbors, from which we can build !! the tight-binding hopping term of the corresponding !! lattice hamiltonian. type ( xy_lattice ), intent ( in ) :: lattice real ( 8 ), allocatable , intent ( out ) :: distance_set (:) real ( 8 ), allocatable , intent ( out ) :: shell_table (:,:) real ( 8 ) :: distance type ( xy_site ) :: A , B integer :: L , i , j , k L = size ( lattice % site ) allocate ( shell_table ( L , L ), distance_set ( L ** 2 )) shell_table = 0 d0 ! init the shells distance_set = 0 d0 ! and the set k = 0 ! unique distance counter do i = 1 , L - 1 do j = i + 1 , L A = lattice % site ( i ) B = lattice % site ( j ) distance = xy_distance ( A , B ) shell_table ( i , j ) = distance shell_table ( j , i ) = distance if ( all ( abs ( distance_set - distance ) > 1 d - 12 )) then k = k + 1 distance_set ( k ) = distance end if enddo enddo ! Shrink the set to the actual required size: distance_set = pack ( distance_set , distance_set /= 0 d0 ) call sort ( distance_set ) end subroutine xy_shells","tags":"","loc":"proc/xy_shells.html"},{"title":"hex_direction – HoneyTools","text":"public pure function hex_direction(idir) result(dir) Return a direction in pseudo-3D hex space, given a (signed) integer label Arguments Type Intent Optional Attributes Name integer, intent(in) :: idir Return Value type( hex ) Called by proc~~hex_direction~~CalledByGraph proc~hex_direction hex_neighbors::hex_direction proc~hex_hop hex_neighbors::hex_hop proc~hex_hop->proc~hex_direction proc~hex_nearest hex_neighbors::hex_nearest proc~hex_nearest->proc~hex_hop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex_direction.html"},{"title":"hex_hop – HoneyTools","text":"public pure function hex_hop(H, i) result(Ni) Return the nearest neighbor of H, \nby hopping in the i-th direction.\nYou can feed any i ∈ ℤ, but you'd\nget only 6 inequivalent neighbors Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: H integer, intent(in) :: i Return Value type( hex ) Calls proc~~hex_hop~~CallsGraph proc~hex_hop hex_neighbors::hex_hop proc~hex_direction hex_neighbors::hex_direction proc~hex_hop->proc~hex_direction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex_hop~~CalledByGraph proc~hex_hop hex_neighbors::hex_hop proc~hex_nearest hex_neighbors::hex_nearest proc~hex_nearest->proc~hex_hop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex_hop.html"},{"title":"hex_nearest – HoneyTools","text":"public pure function hex_nearest(H) result(nnvec) Return the vector of all nearest hex_neighbors of hex H Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: H Return Value type( hex ), dimension(N) Calls proc~~hex_nearest~~CallsGraph proc~hex_nearest hex_neighbors::hex_nearest proc~hex_hop hex_neighbors::hex_hop proc~hex_nearest->proc~hex_hop proc~hex_direction hex_neighbors::hex_direction proc~hex_hop->proc~hex_direction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex_nearest.html"},{"title":"xy_plot – HoneyTools","text":"public  subroutine xy_plot(lattice, nn_mask, nnn_mask, backend, figure_name, script_name, set_terminal) CURRENTLY GNUPLOT DOES NOT SUPPORT NN AND NNN LINKS, HELP IS WELCOME!\nSimple plotter for class(xy_lattice) objects. If optional argument nn_mask\nis passed it draws the nearest-neighbor bonds too. Similarly, if optional\nargument nnn_mask is passed a dashed link to next-nearest neighbors would\nbe drawed. Otherwise only lallice sites. It features two backends, giving\naccess to either matplotlib(pyplot) or gnuplot internal machinery. Either\nlibrary needs to be installed in your system for hex_plot to work.\nYou can specify a figure_name to save the plot to disk. If not specified\nthe plot would be just displayed in a popup window (or the terminal with\nsuitable configuration of the gnuplot backend) and a corresponding script\nsaved, aiming at fast reproduction (the script will all contain data).\nThe script has a default name (hex_plot.{py,gp}), but you can optionally\ngive your own custom string, do not forget the appropriate file extension.\nRegarding output formats instead, the two backends have slightly different\nbehavior: pyplot would infer the format from the given file extension in\nfigure_name, whilst gnuplot does need a proper \"output terminal\" to be set.\nYou can do that by passing the optional set_parameter variable. Refer to\noriginal gnuplot documentation for the list of available terminals and how\nthey should be chosen. For convenience we report that you can get the list\nof (system dependent) available terminals in your console by executing the\ngnuplot -e \"set terminal\" command in your shell. Furthermore all systems\nshould be compatible with the \"dumb\" terminal option, which would direct\nthe plot to the terminal itself, in the form of ASCII art. This can be\nvery useful for HPC workflows. Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice logical, intent(in), optional, allocatable :: nn_mask (:,:) logical, intent(in), optional, allocatable :: nnn_mask (:,:) character(len=*), intent(in), optional :: backend default: \"pyplot\" (or \"gnuplot\") character(len=*), intent(in), optional :: figure_name character(len=*), intent(in), optional :: script_name character(len=*), intent(in), optional :: set_terminal relevant to gnuplot backend Calls proc~~xy_plot~~CallsGraph proc~xy_plot honeyplots::xy_plot add_plot add_plot proc~xy_plot->add_plot filename filename proc~xy_plot->filename initialize initialize proc~xy_plot->initialize interface~plot honeyplots::plot proc~xy_plot->interface~plot options options proc~xy_plot->options proc~get_sublattice xy_coordinates::get_sublattice proc~xy_plot->proc~get_sublattice savefig savefig proc~xy_plot->savefig showfig showfig proc~xy_plot->showfig site site proc~xy_plot->site xlabel xlabel proc~xy_plot->xlabel ylabel ylabel proc~xy_plot->ylabel interface~plot->proc~xy_plot proc~hex_plot honeyplots::hex_plot interface~plot->proc~hex_plot proc~hex_plot->add_plot proc~hex_plot->filename proc~hex_plot->initialize proc~hex_plot->interface~plot proc~hex_plot->options proc~hex_plot->savefig proc~hex_plot->showfig proc~hex_plot->xlabel proc~hex_plot->ylabel proc~hex2corner xy_coordinates::hex2corner proc~hex_plot->proc~hex2corner proc~hex2corner->site proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~xy_plot~~CalledByGraph proc~xy_plot honeyplots::xy_plot interface~plot honeyplots::plot proc~xy_plot->interface~plot interface~plot->proc~xy_plot proc~hex_plot honeyplots::hex_plot interface~plot->proc~hex_plot proc~hex_plot->interface~plot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code xy_plot Source Code subroutine xy_plot ( lattice , nn_mask , nnn_mask , backend , figure_name , script_name , set_terminal ) !! >>> CURRENTLY GNUPLOT DOES NOT SUPPORT NN AND NNN LINKS, HELP IS WELCOME! !! Simple plotter for class(xy_lattice) objects. If optional argument nn_mask !! is passed it draws the nearest-neighbor bonds too. Similarly, if optional !! argument nnn_mask is passed a dashed link to next-nearest neighbors would !! be drawed. Otherwise only lallice sites. It features two backends, giving !! access to either matplotlib(pyplot) or gnuplot internal machinery. Either !! library needs to be installed in your system for hex_plot to work. !! You can specify a figure_name to save the plot to disk. If not specified !! the plot would be just displayed in a popup window (or the terminal with !! suitable configuration of the gnuplot backend) and a corresponding script !! saved, aiming at fast reproduction (the script will all contain data). !! The script has a default name (hex_plot.{py,gp}), but you can optionally !! give your own custom string, do not forget the appropriate file extension. !! Regarding output formats instead, the two backends have slightly different !! behavior: pyplot would infer the format from the given file extension in !! figure_name, whilst gnuplot does need a proper \"output terminal\" to be set. !! You can do that by passing the optional set_parameter variable. Refer to !! original gnuplot documentation for the list of available terminals and how !! they should be chosen. For convenience we report that you can get the list !! of (system dependent) available terminals in your console by executing the !! gnuplot -e \"set terminal\" command in your shell. Furthermore all systems !! should be compatible with the \"dumb\" terminal option, which would direct !! the plot to the terminal itself, in the form of ASCII art. This can be !! very useful for HPC workflows. type ( xy_lattice ), intent ( in ) :: lattice logical , allocatable , intent ( in ), optional :: nn_mask (:,:) logical , allocatable , intent ( in ), optional :: nnn_mask (:,:) character ( * ), intent ( in ), optional :: backend !! default: \"pyplot\" (or \"gnuplot\") character ( * ), intent ( in ), optional :: figure_name character ( * ), intent ( in ), optional :: script_name character ( * ), intent ( in ), optional :: set_terminal !! relevant to gnuplot backend type ( xy_lattice ) :: sublattice character ( 8 ) :: engine character ( 32 ) :: source_name real ( 8 ), allocatable :: Ax (:), Ay (:) real ( 8 ), allocatable :: Bx (:), By (:) real ( 8 ), dimension ( 2 ) :: x , y , x1 , y1 , x2 , y2 type ( pyplot ) :: plt type ( gpf ) :: gnu integer :: i , j , k , l sublattice = get_sublattice ( lattice , \"A\" ) Ax = sublattice % site % x Ay = sublattice % site % y sublattice = get_sublattice ( lattice , \"B\" ) Bx = sublattice % site % x By = sublattice % site % y if ( present ( backend )) then engine = trim ( backend ) else engine = \"pyplot\" end if select case ( trim ( engine )) case default print * , \"unknown backend: no plot generated\" case ( \"pyplot\" ) call plt % initialize ( xlabel = 'x' , ylabel = 'y' , axis_equal = . true .) ! Nearest Neighbor Links if ( present ( nn_mask )) then do i = 1 , size ( nn_mask , 1 ) do j = 1 , size ( nn_mask , 1 ) if ( nn_mask ( i , j )) then x ( 1 ) = lattice % site ( i )% x x ( 2 ) = lattice % site ( j )% x y ( 1 ) = lattice % site ( i )% y y ( 2 ) = lattice % site ( j )% y call plt % add_plot ( x , y , label = '' , linestyle = '-k' , linewidth = 2 ) endif enddo enddo endif ! Next Nearest Neighbors if ( present ( nnn_mask )) then do i = 1 , size ( nnn_mask , 1 ) do j = 1 , size ( nnn_mask , 1 ) if ( nnn_mask ( i , j )) then x ( 1 ) = lattice % site ( i )% x x ( 2 ) = lattice % site ( j )% x y ( 1 ) = lattice % site ( i )% y y ( 2 ) = lattice % site ( j )% y call plt % add_plot ( x , y , label = '' , linestyle = ':k' , linewidth = 1 ) endif enddo enddo endif ! Sublattice \"A\" call plt % add_plot ( Ax , Ay , label = '' , linestyle = 'o' , markersize = 5 ) ! Sublattice \"B call plt % add_plot ( Bx , By , label = '' , linestyle = 'o' , markersize = 5 ) if ( present ( script_name )) then source_name = script_name else source_name = \"hex_plot.py\" endif if ( present ( figure_name )) then call plt % savefig ( trim ( figure_name ), pyfile = trim ( source_name )) print * print * , \"> PyPlot figure saved to: \" // trim ( figure_name ) print * else print * print * , \"> PyPlot GUI popping up...\" print * call plt % showfig ( pyfile = trim ( source_name )) endif case ( \"gnuplot\" ) if ( present ( script_name )) then source_name = script_name else source_name = \"hex_plot.gp\" endif if ( present ( set_terminal )) then call gnu % options ( \"set term \" // set_terminal // \";\" ) else call gnu % options ( \"set term qt;\" ) endif if ( present ( figure_name )) then call gnu % options ( 'set output \"' // figure_name // '\"' ) endif call gnu % options ( \"set size ratio -1;\" ) ! --> axis equal call gnu % options ( \"unset grid\" ) ! --> grid off call gnu % xlabel ( 'x' ) call gnu % ylabel ( 'y' ) call gnu % filename ( source_name ) print * print * , \"> Gnuplot GUI popping up...\" print * call gnu % plot ( & x1 = Ax , y1 = Ay , & ls1 = 'with points pt 7 ps 1 lc rgb \"#1F77B4\"' , & x2 = Bx , y2 = By , & ls2 = 'with points pt 7 ps 1 lc rgb \"#FF7F0E\"' & ) end select end subroutine xy_plot","tags":"","loc":"proc/xy_plot.html"},{"title":"hex_plot – HoneyTools","text":"public  subroutine hex_plot(layout, hexagons, backend, figure_name, script_name, set_terminal) Simple plotter for arrays of type(hex). It features two backends, giving\naccess to either matplotlib(pyplot) or gnuplot internal machinery. Either\nlibrary needs to be installed in your system for hex_plot to work.\nYou can specify a figure_name to save the plot to disk. If not specified\nthe plot would be just displayed in a popup window (or the terminal with\nsuitable configuration of the gnuplot backend) and a corresponding script\nsaved, aiming at fast reproduction (the script will all contain data).\nThe script has a default name (hex_plot.{py,gp}), but you can optionally\ngive your own custom string, do not forget the appropriate file extension.\nRegarding output formats instead, the two backends have slightly different\nbehavior: pyplot would infer the format from the given file extension in\nfigure_name, whilst gnuplot does need a proper \"output terminal\" to be set.\nYou can do that by passing the optional set_parameter variable. Refer to\noriginal gnuplot documentation for the list of available terminals and how\nthey should be chosen. For convenience we report that you can get the list\nof (system dependent) available terminals in your console by executing the\ngnuplot -e \"set terminal\" command in your shell. Furthermore all systems\nshould be compatible with the \"dumb\" terminal option, which would direct\nthe plot to the terminal itself, in the form of ASCII art. This can be\nvery useful for HPC workflows. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: hexagons (:) character(len=*), intent(in), optional :: backend default: \"pyplot\" (or \"gnuplot\") character(len=*), intent(in), optional :: figure_name character(len=*), intent(in), optional :: script_name character(len=*), intent(in), optional :: set_terminal relevant to gnuplot backend Calls proc~~hex_plot~~CallsGraph proc~hex_plot honeyplots::hex_plot add_plot add_plot proc~hex_plot->add_plot filename filename proc~hex_plot->filename initialize initialize proc~hex_plot->initialize interface~plot honeyplots::plot proc~hex_plot->interface~plot options options proc~hex_plot->options proc~hex2corner xy_coordinates::hex2corner proc~hex_plot->proc~hex2corner savefig savefig proc~hex_plot->savefig showfig showfig proc~hex_plot->showfig xlabel xlabel proc~hex_plot->xlabel ylabel ylabel proc~hex_plot->ylabel interface~plot->proc~hex_plot proc~xy_plot honeyplots::xy_plot interface~plot->proc~xy_plot proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset site site proc~hex2corner->site origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur proc~xy_plot->add_plot proc~xy_plot->filename proc~xy_plot->initialize proc~xy_plot->interface~plot proc~xy_plot->options proc~xy_plot->savefig proc~xy_plot->showfig proc~xy_plot->xlabel proc~xy_plot->ylabel proc~xy_plot->site proc~get_sublattice xy_coordinates::get_sublattice proc~xy_plot->proc~get_sublattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex_plot~~CalledByGraph proc~hex_plot honeyplots::hex_plot interface~plot honeyplots::plot proc~hex_plot->interface~plot interface~plot->proc~hex_plot proc~xy_plot honeyplots::xy_plot interface~plot->proc~xy_plot proc~xy_plot->interface~plot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_plot Source Code subroutine hex_plot ( layout , hexagons , backend , figure_name , script_name , set_terminal ) !! Simple plotter for arrays of type(hex). It features two backends, giving !! access to either matplotlib(pyplot) or gnuplot internal machinery. Either !! library needs to be installed in your system for hex_plot to work. !! You can specify a figure_name to save the plot to disk. If not specified !! the plot would be just displayed in a popup window (or the terminal with !! suitable configuration of the gnuplot backend) and a corresponding script !! saved, aiming at fast reproduction (the script will all contain data). !! The script has a default name (hex_plot.{py,gp}), but you can optionally !! give your own custom string, do not forget the appropriate file extension. !! Regarding output formats instead, the two backends have slightly different !! behavior: pyplot would infer the format from the given file extension in !! figure_name, whilst gnuplot does need a proper \"output terminal\" to be set. !! You can do that by passing the optional set_parameter variable. Refer to !! original gnuplot documentation for the list of available terminals and how !! they should be chosen. For convenience we report that you can get the list !! of (system dependent) available terminals in your console by executing the !! gnuplot -e \"set terminal\" command in your shell. Furthermore all systems !! should be compatible with the \"dumb\" terminal option, which would direct !! the plot to the terminal itself, in the form of ASCII art. This can be !! very useful for HPC workflows. type ( unit_cell ), intent ( in ) :: layout type ( hex ), intent ( in ) :: hexagons (:) character ( * ), intent ( in ), optional :: backend !! default: \"pyplot\" (or \"gnuplot\") character ( * ), intent ( in ), optional :: figure_name character ( * ), intent ( in ), optional :: script_name character ( * ), intent ( in ), optional :: set_terminal !! relevant to gnuplot backend character ( 8 ) :: engine character ( 32 ) :: source_name integer :: M type ( pyplot ) :: plt type ( gpf ) :: gnu type ( xy_lattice ), allocatable :: corner (:) real ( 8 ), dimension ( N ) :: xtmp , ytmp real ( 8 ), allocatable :: x (:), y (:) integer :: i , j M = size ( hexagons ) allocate ( x ( N * M ), y ( N * M ), corner ( M )) corner = hex2corner ( layout , hexagons ) do i = 1 , M do j = 1 , N xtmp ( j ) = corner ( i )% site ( j )% x ytmp ( j ) = corner ( i )% site ( j )% y enddo x (( 1 + N * ( i - 1 )): N * i ) = xtmp y (( 1 + N * ( i - 1 )): N * i ) = ytmp enddo if ( present ( backend )) then engine = trim ( backend ) else engine = \"pyplot\" end if select case ( trim ( engine )) case default print * , \"unknown backend: no plot generated\" case ( \"pyplot\" ) call plt % initialize ( xlabel = 'x' , ylabel = 'y' , axis_equal = . true .) call plt % add_plot ( x , y , label = '' , linestyle = 'o' , markersize = 5 ) if ( present ( script_name )) then source_name = script_name else source_name = \"hex_plot.py\" endif if ( present ( figure_name )) then call plt % savefig ( trim ( figure_name ), pyfile = trim ( source_name )) print * print * , \"> PyPlot figure saved to: \" // trim ( figure_name ) print * else print * print * , \"> PyPlot GUI popping up...\" print * call plt % showfig ( pyfile = trim ( source_name )) endif case ( \"gnuplot\" ) if ( present ( script_name )) then source_name = script_name else source_name = \"hex_plot.gp\" endif if ( present ( set_terminal )) then call gnu % options ( \"set term \" // set_terminal // \";\" ) else call gnu % options ( \"set term qt;\" ) endif if ( present ( figure_name )) then call gnu % options ( 'set output \"' // figure_name // '\"' ) endif call gnu % options ( \"set size ratio -1;\" ) ! --> axis equal call gnu % options ( \"unset grid\" ) ! --> grid off call gnu % xlabel ( 'x' ) call gnu % ylabel ( 'y' ) call gnu % filename ( source_name ) print * print * , \"> Gnuplot GUI popping up...\" print * call gnu % plot ( x , y , 'with points pt 7 ps 1 lc rgb \"#1F77B4\"' ) end select end subroutine hex_plot","tags":"","loc":"proc/hex_plot.html"},{"title":"plot – HoneyTools","text":"public interface plot Calls interface~~plot~~CallsGraph interface~plot honeyplots::plot proc~hex_plot honeyplots::hex_plot interface~plot->proc~hex_plot proc~xy_plot honeyplots::xy_plot interface~plot->proc~xy_plot proc~hex_plot->interface~plot add_plot add_plot proc~hex_plot->add_plot filename filename proc~hex_plot->filename initialize initialize proc~hex_plot->initialize options options proc~hex_plot->options proc~hex2corner xy_coordinates::hex2corner proc~hex_plot->proc~hex2corner savefig savefig proc~hex_plot->savefig showfig showfig proc~hex_plot->showfig xlabel xlabel proc~hex_plot->xlabel ylabel ylabel proc~hex_plot->ylabel proc~xy_plot->interface~plot proc~xy_plot->add_plot proc~xy_plot->filename proc~xy_plot->initialize proc~xy_plot->options proc~get_sublattice xy_coordinates::get_sublattice proc~xy_plot->proc~get_sublattice proc~xy_plot->savefig proc~xy_plot->showfig site site proc~xy_plot->site proc~xy_plot->xlabel proc~xy_plot->ylabel proc~hex2corner->site proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~plot~~CalledByGraph interface~plot honeyplots::plot proc~hex_plot honeyplots::hex_plot interface~plot->proc~hex_plot proc~xy_plot honeyplots::xy_plot interface~plot->proc~xy_plot proc~hex_plot->interface~plot proc~xy_plot->interface~plot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures xy_plot hex_plot Module Procedures public  subroutine xy_plot (lattice, nn_mask, nnn_mask, backend, figure_name, script_name, set_terminal) CURRENTLY GNUPLOT DOES NOT SUPPORT NN AND NNN LINKS, HELP IS WELCOME!\nSimple plotter for class(xy_lattice) objects. If optional argument nn_mask\nis passed it draws the nearest-neighbor bonds too. Similarly, if optional\nargument nnn_mask is passed a dashed link to next-nearest neighbors would\nbe drawed. Otherwise only lallice sites. It features two backends, giving\naccess to either matplotlib(pyplot) or gnuplot internal machinery. Either\nlibrary needs to be installed in your system for hex_plot to work.\nYou can specify a figure_name to save the plot to disk. If not specified\nthe plot would be just displayed in a popup window (or the terminal with\nsuitable configuration of the gnuplot backend) and a corresponding script\nsaved, aiming at fast reproduction (the script will all contain data).\nThe script has a default name (hex_plot.{py,gp}), but you can optionally\ngive your own custom string, do not forget the appropriate file extension.\nRegarding output formats instead, the two backends have slightly different\nbehavior: pyplot would infer the format from the given file extension in\nfigure_name, whilst gnuplot does need a proper \"output terminal\" to be set.\nYou can do that by passing the optional set_parameter variable. Refer to\noriginal gnuplot documentation for the list of available terminals and how\nthey should be chosen. For convenience we report that you can get the list\nof (system dependent) available terminals in your console by executing the\ngnuplot -e \"set terminal\" command in your shell. Furthermore all systems\nshould be compatible with the \"dumb\" terminal option, which would direct\nthe plot to the terminal itself, in the form of ASCII art. This can be\nvery useful for HPC workflows. Read more… Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice logical, intent(in), optional, allocatable :: nn_mask (:,:) logical, intent(in), optional, allocatable :: nnn_mask (:,:) character(len=*), intent(in), optional :: backend default: \"pyplot\" (or \"gnuplot\") character(len=*), intent(in), optional :: figure_name character(len=*), intent(in), optional :: script_name character(len=*), intent(in), optional :: set_terminal relevant to gnuplot backend public  subroutine hex_plot (layout, hexagons, backend, figure_name, script_name, set_terminal) Simple plotter for arrays of type(hex). It features two backends, giving\naccess to either matplotlib(pyplot) or gnuplot internal machinery. Either\nlibrary needs to be installed in your system for hex_plot to work.\nYou can specify a figure_name to save the plot to disk. If not specified\nthe plot would be just displayed in a popup window (or the terminal with\nsuitable configuration of the gnuplot backend) and a corresponding script\nsaved, aiming at fast reproduction (the script will all contain data).\nThe script has a default name (hex_plot.{py,gp}), but you can optionally\ngive your own custom string, do not forget the appropriate file extension.\nRegarding output formats instead, the two backends have slightly different\nbehavior: pyplot would infer the format from the given file extension in\nfigure_name, whilst gnuplot does need a proper \"output terminal\" to be set.\nYou can do that by passing the optional set_parameter variable. Refer to\noriginal gnuplot documentation for the list of available terminals and how\nthey should be chosen. For convenience we report that you can get the list\nof (system dependent) available terminals in your console by executing the\ngnuplot -e \"set terminal\" command in your shell. Furthermore all systems\nshould be compatible with the \"dumb\" terminal option, which would direct\nthe plot to the terminal itself, in the form of ASCII art. This can be\nvery useful for HPC workflows. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: hexagons (:) character(len=*), intent(in), optional :: backend default: \"pyplot\" (or \"gnuplot\") character(len=*), intent(in), optional :: figure_name character(len=*), intent(in), optional :: script_name character(len=*), intent(in), optional :: set_terminal relevant to gnuplot backend","tags":"","loc":"interface/plot.html"},{"title":"hex_supercell – HoneyTools","text":"public pure function hex_supercell(rows, cols) result(hexagons) Build a honeycomb supercell (parallelogram) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows integer, intent(in) :: cols Return Value type( hex ), (rows*cols) Called by proc~~hex_supercell~~CalledByGraph proc~hex_supercell hex_geometries::hex_supercell proc~get_supercell honeytools::get_supercell proc~get_supercell->proc~hex_supercell Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_supercell Source Code pure function hex_supercell ( rows , cols ) result ( hexagons ) !! Build a honeycomb supercell (parallelogram) integer , intent ( in ) :: rows , cols type ( hex ) :: hexagons ( rows * cols ) integer :: i , j , k k = 0 do i = 1 , rows do j = 1 , cols k = k + 1 hexagons ( k ) = hex ( q = i , r = j ) enddo enddo end function hex_supercell","tags":"","loc":"proc/hex_supercell.html"},{"title":"hex_triangle – HoneyTools","text":"public pure function hex_triangle(size) result(hexagons) Build a triangle-shaped honeycomb flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: size Return Value type( hex ), allocatable, (:) Calls proc~~hex_triangle~~CallsGraph proc~hex_triangle hex_geometries::hex_triangle assert assert proc~hex_triangle->assert proc~hex_insert hex_geometries::hex_insert proc~hex_triangle->proc~hex_insert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex_triangle~~CalledByGraph proc~hex_triangle hex_geometries::hex_triangle proc~get_triangle honeytools::get_triangle proc~get_triangle->proc~hex_triangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_triangle Source Code pure function hex_triangle ( size ) result ( hexagons ) !! Build a triangle-shaped honeycomb flake integer , intent ( in ) :: size type ( hex ), allocatable :: hexagons (:) integer :: i , j call assert ( size > 1 , \"triangle size > 1\" , size ) do i = 0 , size do j = 0 , size - i call hex_insert ( hexagons , hex ( i , j )) enddo enddo end function hex_triangle","tags":"","loc":"proc/hex_triangle.html"},{"title":"hex_flake – HoneyTools","text":"public pure function hex_flake(radius) result(hexagons) Build a hexagon-shaped honeycomb flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: radius Return Value type( hex ), allocatable, (:) Calls proc~~hex_flake~~CallsGraph proc~hex_flake hex_geometries::hex_flake proc~hex_insert hex_geometries::hex_insert proc~hex_flake->proc~hex_insert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex_flake~~CalledByGraph proc~hex_flake hex_geometries::hex_flake proc~get_flake honeytools::get_flake proc~get_flake->proc~hex_flake Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_flake Source Code pure function hex_flake ( radius ) result ( hexagons ) !! Build a hexagon-shaped honeycomb flake integer , intent ( in ) :: radius type ( hex ), allocatable :: hexagons (:) integer :: i , j do i = - radius , + radius do j = max ( - radius , - i - radius ), min ( radius , - i + radius ) call hex_insert ( hexagons , hex ( i , j )) enddo enddo end function hex_flake","tags":"","loc":"proc/hex_flake.html"},{"title":"hex_armchair_stripe – HoneyTools","text":"public pure function hex_armchair_stripe(height, width) result(hexagons) Build a armchair-on-top honeycomb stripe/ribbon\nCONVERSION TO XY SITES REQUIRES ARMCHAIR LAYOUT Arguments Type Intent Optional Attributes Name integer, intent(in) :: height integer, intent(in) :: width Return Value type( hex ), allocatable, (:) Calls proc~~hex_armchair_stripe~~CallsGraph proc~hex_armchair_stripe hex_geometries::hex_armchair_stripe proc~hex_insert hex_geometries::hex_insert proc~hex_armchair_stripe->proc~hex_insert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex_armchair_stripe~~CalledByGraph proc~hex_armchair_stripe hex_geometries::hex_armchair_stripe proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex_armchair_stripe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_armchair_stripe Source Code pure function hex_armchair_stripe ( height , width ) result ( hexagons ) !! Build a armchair-on-top honeycomb stripe/ribbon !! CONVERSION TO XY SITES REQUIRES ARMCHAIR LAYOUT integer , intent ( in ) :: height , width type ( hex ), allocatable :: hexagons (:) integer :: i , j , offset do i = 1 , width offset = floor ( i / 2.d0 ) do j = 1 - offset , height - offset call hex_insert ( hexagons , hex ( i , j )) enddo enddo end function hex_armchair_stripe","tags":"","loc":"proc/hex_armchair_stripe.html"},{"title":"hex_zigzag_stripe – HoneyTools","text":"public pure function hex_zigzag_stripe(height, width) result(hexagons) Build a zigzag-on-top honeycomb stripe/ribbon\nCONVERSION TO XY SITES REQUIRES ZIGZAG LAYOUT Arguments Type Intent Optional Attributes Name integer, intent(in) :: height integer, intent(in) :: width Return Value type( hex ), allocatable, (:) Calls proc~~hex_zigzag_stripe~~CallsGraph proc~hex_zigzag_stripe hex_geometries::hex_zigzag_stripe proc~hex_insert hex_geometries::hex_insert proc~hex_zigzag_stripe->proc~hex_insert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex_zigzag_stripe~~CalledByGraph proc~hex_zigzag_stripe hex_geometries::hex_zigzag_stripe proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex_zigzag_stripe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_zigzag_stripe Source Code pure function hex_zigzag_stripe ( height , width ) result ( hexagons ) !! Build a zigzag-on-top honeycomb stripe/ribbon !! CONVERSION TO XY SITES REQUIRES ZIGZAG LAYOUT integer , intent ( in ) :: height , width type ( hex ), allocatable :: hexagons (:) integer :: i , j , offset do i = 1 , height offset = floor ( i / 2.d0 ) do j = 1 - offset , width - offset call hex_insert ( hexagons , hex ( i , j )) enddo enddo end function hex_zigzag_stripe","tags":"","loc":"proc/hex_zigzag_stripe.html"},{"title":"hex_line – HoneyTools","text":"public pure function hex_line(A, B) result(line) Draw a line between A and B, in hex space Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex ), allocatable, (:) Calls proc~~hex_line~~CallsGraph proc~hex_line hex_geometries::hex_line proc~hex_distance hex_coordinates::hex_distance proc~hex_line->proc~hex_distance proc~hex_insert hex_geometries::hex_insert proc~hex_line->proc~hex_insert proc~hex_round hex_geometries::hex_round proc~hex_line->proc~hex_round proc~linear_interpolation hex_geometries::linear_interpolation proc~hex_line->proc~linear_interpolation proc~hex_norm hex_coordinates::hex_norm proc~hex_distance->proc~hex_norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_line Source Code pure function hex_line ( A , B ) result ( line ) !! Draw a line between A and B, in hex space type ( hex ), intent ( in ) :: A , B type ( hex ), allocatable :: line (:) real ( 8 ), dimension ( 3 ) :: lntrp integer , dimension ( 3 ) :: ai , bi real ( 8 ), dimension ( 3 ) :: ar , br real ( 8 ) :: step integer :: dist , i dist = hex_distance ( A , B ) step = 1 d0 / max ( dist , 1 ) ! handle A==B :) do i = 0 , dist ! Unpack ai = [ A % q , A % r , A % s ] bi = [ B % q , B % r , B % s ] ! Cast ar = real ( ai , 8 ) br = real ( bi , 8 ) ! Nudge ar ( 1 : 2 ) = ar ( 1 : 2 ) + 1 d - 6 ar ( 3 ) = ar ( 3 ) - 2 d - 6 br ( 1 : 2 ) = br ( 1 : 2 ) + 1 d - 6 br ( 3 ) = br ( 3 ) - 2 d - 6 ! Interpolate lntrp = linear_interpolation ( ar , br , step * i ) ! Grow the vect call hex_insert ( line , hex_round ( lntrp )) enddo end function hex_line","tags":"","loc":"proc/hex_line.html"},{"title":"linear_interpolation – HoneyTools","text":"private pure elemental function linear_interpolation(a, b, t) result(l) Linear interpolation from a to b, with step t\na + (b - a) * t = a * (1-t) + b * t\nfor better floating-point precision Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: t Return Value real(kind=8) Called by proc~~linear_interpolation~~CalledByGraph proc~linear_interpolation hex_geometries::linear_interpolation proc~hex_line hex_geometries::hex_line proc~hex_line->proc~linear_interpolation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code linear_interpolation Source Code pure elemental function linear_interpolation ( a , b , t ) result ( l ) !! Linear interpolation from a to b, with step t !! a + (b - a) * t = a * (1-t) + b * t !! for better floating-point precision real ( 8 ), intent ( in ) :: a , b , t real ( 8 ) :: l l = a * ( 1 - t ) + b * t end function linear_interpolation","tags":"","loc":"proc/linear_interpolation.html"},{"title":"hex_round – HoneyTools","text":"private pure function hex_round(xyz) result(qrs) Round a triplet of reals to a proper hex object this needs to preserve the q+r+s==0 condition Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: xyz (3) Return Value type( hex ) Called by proc~~hex_round~~CalledByGraph proc~hex_round hex_geometries::hex_round proc~hex_line hex_geometries::hex_line proc~hex_line->proc~hex_round Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_round Source Code pure function hex_round ( xyz ) result ( qrs ) !! Round a triplet of reals to a proper hex object !! > this needs to preserve the q+r+s==0 condition real ( 8 ), intent ( in ) :: xyz ( 3 ) type ( hex ) :: qrs real ( 8 ) :: x , y , z integer :: q , r , s real ( 8 ) :: dq , dr , ds ! Unpack x = xyz ( 1 ) y = xyz ( 2 ) z = xyz ( 3 ) ! Round xyz q = nint ( x ) r = nint ( y ) s = nint ( z ) ! Eval diffs dq = abs ( x - q ) dr = abs ( x - r ) ds = abs ( x - s ) ! Reset bigger diff if ( dq > dr . and . dq > ds ) then q = - r - s elseif ( dr > ds ) then r = - q - s else s = - q - r endif ! Repack qrs = hex ( q , r , s ) ! internal assertion :) end function hex_round","tags":"","loc":"proc/hex_round.html"},{"title":"hex_insert – HoneyTools","text":"public pure subroutine hex_insert(vec, val) Utility to grow type(hex) arrays, it is a\npoor man implementation of a dynamic array\ninsertion, a là std::vector (but with no\npreallocation and smart doubling...) Arguments Type Intent Optional Attributes Name type( hex ), intent(inout), allocatable :: vec (:) type( hex ), intent(in) :: val Called by proc~~hex_insert~~CalledByGraph proc~hex_insert hex_geometries::hex_insert proc~hex_armchair_stripe hex_geometries::hex_armchair_stripe proc~hex_armchair_stripe->proc~hex_insert proc~hex_flake hex_geometries::hex_flake proc~hex_flake->proc~hex_insert proc~hex_line hex_geometries::hex_line proc~hex_line->proc~hex_insert proc~hex_triangle hex_geometries::hex_triangle proc~hex_triangle->proc~hex_insert proc~hex_zigzag_stripe hex_geometries::hex_zigzag_stripe proc~hex_zigzag_stripe->proc~hex_insert proc~get_flake honeytools::get_flake proc~get_flake->proc~hex_flake proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex_armchair_stripe proc~get_stripe->proc~hex_zigzag_stripe proc~get_triangle honeytools::get_triangle proc~get_triangle->proc~hex_triangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code hex_insert Source Code pure subroutine hex_insert ( vec , val ) !! Utility to grow type(hex) arrays, it is a !! poor man implementation of a dynamic array !! insertion, a là std::vector (but with no !! preallocation and smart doubling...) type ( hex ), intent ( inout ), allocatable :: vec (:) type ( hex ), intent ( in ) :: val type ( hex ), allocatable :: tmp (:) integer :: len if ( allocated ( vec )) then len = size ( vec ) allocate ( tmp ( len + 1 )) tmp (: len ) = vec call move_alloc ( tmp , vec ) len = len + 1 else len = 1 allocate ( vec ( len )) end if ! Insert val at back vec ( len ) = val end subroutine hex_insert","tags":"","loc":"proc/hex_insert.html"},{"title":"xy_distance – HoneyTools","text":"public pure elemental function xy_distance(A, B) result(d) Polymorphic euclidean distance for xy class Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value real(kind=8) Calls proc~~xy_distance~~CallsGraph proc~xy_distance xy_coordinates::xy_distance proc~xy_norm xy_coordinates::xy_norm proc~xy_distance->proc~xy_norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~xy_distance~~CalledByGraph proc~xy_distance xy_coordinates::xy_distance proc~xy_shells xy_neighbors::xy_shells proc~xy_shells->proc~xy_distance proc~xy_nearest_neighbors xy_neighbors::xy_nearest_neighbors proc~xy_nearest_neighbors->proc~xy_shells proc~xy_next_nearest_neighbors xy_neighbors::xy_next_nearest_neighbors proc~xy_next_nearest_neighbors->proc~xy_shells Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_distance.html"},{"title":"hex2site – HoneyTools","text":"public pure elemental function hex2site(layout, H, label) result(site) Convert hex coordinates to real 2D lattice sites\n[returning the xy coordinates for the unique unit-cell,\n sites \"A\" and \"B\": this of course does not account for\n border effects, so would be suitable only for simple,\n periodized, systems, which for now are out of scope.]\nActual real-space layout has to be specified by passing\na (scalar) unit_cell object. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: H character(len=1), intent(in) :: label A or B Return Value type( xy_site ) Calls proc~~hex2site~~CallsGraph proc~hex2site xy_coordinates::hex2site proc~hex2center xy_coordinates::hex2center proc~hex2site->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2site->proc~ith_corner_offset origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex2site.html"},{"title":"hex2corner – HoneyTools","text":"public pure elemental function hex2corner(layout, H) result(corner) Convert hex coordinates to real 2D space\n[returning the xy coordinates for the hexagon corners,\n as appropriatiely wrapped in the \"xy_lattice\" type]\nActual real-space layout has to be specified by passing\na (scalar) unit_cell object. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: H Return Value type( xy_lattice ) Calls proc~~hex2corner~~CallsGraph proc~hex2corner xy_coordinates::hex2corner proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset site site proc~hex2corner->site origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex2corner~~CalledByGraph proc~hex2corner xy_coordinates::hex2corner proc~hex2lattice xy_coordinates::hex2lattice proc~hex2lattice->proc~hex2corner proc~hex_plot honeyplots::hex_plot proc~hex_plot->proc~hex2corner interface~plot honeyplots::plot proc~hex_plot->interface~plot interface~plot->proc~hex_plot proc~xy_plot honeyplots::xy_plot interface~plot->proc~xy_plot proc~get_flake honeytools::get_flake proc~get_flake->proc~hex2lattice proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex2lattice proc~get_supercell honeytools::get_supercell proc~get_supercell->proc~hex2lattice proc~get_triangle honeytools::get_triangle proc~get_triangle->proc~hex2lattice proc~xy_plot->interface~plot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex2corner.html"},{"title":"hex2center – HoneyTools","text":"public pure elemental function hex2center(layout, H) result(center) Convert hex coordinates to real 2D space\n[returning the xy coordinates of the hexagon center]\nActual real-space layout has to be specified by passing\na (scalar) unit_cell object. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: H Return Value type( xy ) Calls proc~~hex2center~~CallsGraph proc~hex2center xy_coordinates::hex2center origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex2center~~CalledByGraph proc~hex2center xy_coordinates::hex2center proc~hex2corner xy_coordinates::hex2corner proc~hex2corner->proc~hex2center proc~hex2site xy_coordinates::hex2site proc~hex2site->proc~hex2center proc~hex2lattice xy_coordinates::hex2lattice proc~hex2lattice->proc~hex2corner proc~hex_plot honeyplots::hex_plot proc~hex_plot->proc~hex2corner interface~plot honeyplots::plot proc~hex_plot->interface~plot interface~plot->proc~hex_plot proc~xy_plot honeyplots::xy_plot interface~plot->proc~xy_plot proc~get_flake honeytools::get_flake proc~get_flake->proc~hex2lattice proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex2lattice proc~get_supercell honeytools::get_supercell proc~get_supercell->proc~hex2lattice proc~get_triangle honeytools::get_triangle proc~get_triangle->proc~hex2lattice proc~xy_plot->interface~plot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex2center.html"},{"title":"hex2lattice – HoneyTools","text":"public pure function hex2lattice(layout, hexagons) result(lattice) Generate a type(xy_lattice) object from any given hex\narray, provided a suitable layout (unit-cell) Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: hexagons (:) Return Value type( xy_lattice ) Calls proc~~hex2lattice~~CallsGraph proc~hex2lattice xy_coordinates::hex2lattice proc~hex2corner xy_coordinates::hex2corner proc~hex2lattice->proc~hex2corner proc~xy_ordered_union xy_coordinates::xy_ordered_union proc~hex2lattice->proc~xy_ordered_union proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset site site proc~hex2corner->site proc~push_back xy_coordinates::xy_lattice%push_back proc~xy_ordered_union->proc~push_back proc~xy_ordered_union->site origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur proc~push_back->site Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hex2lattice~~CalledByGraph proc~hex2lattice xy_coordinates::hex2lattice proc~get_flake honeytools::get_flake proc~get_flake->proc~hex2lattice proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex2lattice proc~get_supercell honeytools::get_supercell proc~get_supercell->proc~hex2lattice proc~get_triangle honeytools::get_triangle proc~get_triangle->proc~hex2lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/hex2lattice.html"},{"title":"get_sublattice – HoneyTools","text":"public pure elemental function get_sublattice(lattice, label) result(sublattice) Extract sublattice, given a lattice and a label (\"A\" or \"B\") Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice character(len=1), intent(in) :: label A or B Return Value type( xy_lattice ) Called by proc~~get_sublattice~~CalledByGraph proc~get_sublattice xy_coordinates::get_sublattice proc~xy_plot honeyplots::xy_plot proc~xy_plot->proc~get_sublattice interface~plot honeyplots::plot proc~xy_plot->interface~plot interface~plot->proc~xy_plot proc~hex_plot honeyplots::hex_plot interface~plot->proc~hex_plot proc~hex_plot->interface~plot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/get_sublattice.html"},{"title":"xy_ordered_union – HoneyTools","text":"public pure function xy_ordered_union(A, B) result(C) An ordered-keys set union for xy_lattices.\nIt compares the lattice sites, looking at\ntheir x and y coordinates only: equal x,y\nentries are inserted in C just once, so to\nmake it a set. A and B must be sets too.\nThe sublattice labels are preserved in the\nprocess, assuming that two sites with the\nsame x,y pertain to the same sublattice.\nFor A the keys are assumed to be 1:size(A),\nand preserved as such (with an assertion).\nThe keys of B are instead discarded, so to\nbe replaced by size(A):size(C), which thus\namounts to have result C uniquely indexed\nas 1, 2, ... , size(A) + size(B).\nThis allows building consistently indexed\nmatrices to act on the lattice array, such\nas real-space tight-binding hamiltonians.\nThe keys would then be used to index other\nreal space quantities, such as LDOS, Chern\nmarker, local magnetization, and so on. Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: A type( xy_lattice ), intent(in) :: B Return Value type( xy_lattice ) Calls proc~~xy_ordered_union~~CallsGraph proc~xy_ordered_union xy_coordinates::xy_ordered_union proc~push_back xy_coordinates::xy_lattice%push_back proc~xy_ordered_union->proc~push_back site site proc~xy_ordered_union->site proc~push_back->site Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~xy_ordered_union~~CalledByGraph proc~xy_ordered_union xy_coordinates::xy_ordered_union proc~hex2lattice xy_coordinates::hex2lattice proc~hex2lattice->proc~xy_ordered_union proc~get_flake honeytools::get_flake proc~get_flake->proc~hex2lattice proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex2lattice proc~get_supercell honeytools::get_supercell proc~get_supercell->proc~hex2lattice proc~get_triangle honeytools::get_triangle proc~get_triangle->proc~hex2lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_ordered_union.html"},{"title":"ith_corner_offset – HoneyTools","text":"private pure function ith_corner_offset(layout, i) result(offset) Compute the i-th offset vector connecting the hexagon center\nto its corners, returning a (scalar) xy coordinate Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout integer, intent(in) :: i Return Value type( xy ) Called by proc~~ith_corner_offset~~CalledByGraph proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner xy_coordinates::hex2corner proc~hex2corner->proc~ith_corner_offset proc~hex2site xy_coordinates::hex2site proc~hex2site->proc~ith_corner_offset proc~hex2lattice xy_coordinates::hex2lattice proc~hex2lattice->proc~hex2corner proc~hex_plot honeyplots::hex_plot proc~hex_plot->proc~hex2corner interface~plot honeyplots::plot proc~hex_plot->interface~plot interface~plot->proc~hex_plot proc~xy_plot honeyplots::xy_plot interface~plot->proc~xy_plot proc~get_flake honeytools::get_flake proc~get_flake->proc~hex2lattice proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex2lattice proc~get_supercell honeytools::get_supercell proc~get_supercell->proc~hex2lattice proc~get_triangle honeytools::get_triangle proc~get_triangle->proc~hex2lattice proc~xy_plot->interface~plot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/ith_corner_offset.html"},{"title":"eq_xy – HoneyTools","text":"private pure elemental function eq_xy(A, B) result(isequal) tolerance equality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Type Bound xy Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical Called by proc~~eq_xy~~CalledByGraph proc~eq_xy xy_coordinates::xy%eq_xy proc~eq_lattice xy_coordinates::xy_lattice%eq_lattice proc~eq_lattice->proc~eq_xy proc~neq_xy xy_coordinates::xy%neq_xy proc~neq_xy->proc~eq_xy proc~neq_lattice xy_coordinates::xy_lattice%neq_lattice proc~neq_lattice->proc~eq_lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/eq_xy.html"},{"title":"neq_xy – HoneyTools","text":"private pure elemental function neq_xy(A, B) result(notequal) tolerance inequality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Type Bound xy Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical Calls proc~~neq_xy~~CallsGraph proc~neq_xy xy_coordinates::xy%neq_xy proc~eq_xy xy_coordinates::xy%eq_xy proc~neq_xy->proc~eq_xy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/neq_xy.html"},{"title":"eq_lattice – HoneyTools","text":"private pure elemental function eq_lattice(A, B) result(isequal) polymorphic equality overload for xy_lattice type Type Bound xy_lattice Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(in) :: A class( xy_lattice ), intent(in) :: B Return Value logical Calls proc~~eq_lattice~~CallsGraph proc~eq_lattice xy_coordinates::xy_lattice%eq_lattice proc~eq_xy xy_coordinates::xy%eq_xy proc~eq_lattice->proc~eq_xy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~eq_lattice~~CalledByGraph proc~eq_lattice xy_coordinates::xy_lattice%eq_lattice proc~neq_lattice xy_coordinates::xy_lattice%neq_lattice proc~neq_lattice->proc~eq_lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/eq_lattice.html"},{"title":"neq_lattice – HoneyTools","text":"private pure elemental function neq_lattice(A, B) result(notequal) polymorphic inequality overload for xy_lattice type Type Bound xy_lattice Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(in) :: A class( xy_lattice ), intent(in) :: B Return Value logical Calls proc~~neq_lattice~~CallsGraph proc~neq_lattice xy_coordinates::xy_lattice%neq_lattice proc~eq_lattice xy_coordinates::xy_lattice%eq_lattice proc~neq_lattice->proc~eq_lattice proc~eq_xy xy_coordinates::xy%eq_xy proc~eq_lattice->proc~eq_xy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/neq_lattice.html"},{"title":"xy_norm – HoneyTools","text":"private pure elemental function xy_norm(A) result(r) polymorphic euclidean norm for xy class Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A Return Value real(kind=8) Called by proc~~xy_norm~~CalledByGraph proc~xy_norm xy_coordinates::xy_norm proc~xy_distance xy_coordinates::xy_distance proc~xy_distance->proc~xy_norm proc~xy_shells xy_neighbors::xy_shells proc~xy_shells->proc~xy_distance proc~xy_nearest_neighbors xy_neighbors::xy_nearest_neighbors proc~xy_nearest_neighbors->proc~xy_shells proc~xy_next_nearest_neighbors xy_neighbors::xy_next_nearest_neighbors proc~xy_next_nearest_neighbors->proc~xy_shells Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_norm.html"},{"title":"push_back – HoneyTools","text":"private pure subroutine push_back(vec, val) Poor man implementation of a dynamic\narray, a là std::vector (but without\npreallocation and smart doubling...) Type Bound xy_lattice Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(inout) :: vec type( xy_site ), intent(in) :: val Calls proc~~push_back~~CallsGraph proc~push_back xy_coordinates::xy_lattice%push_back site site proc~push_back->site Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~push_back~~CalledByGraph proc~push_back xy_coordinates::xy_lattice%push_back proc~xy_ordered_union xy_coordinates::xy_ordered_union proc~xy_ordered_union->proc~push_back proc~hex2lattice xy_coordinates::hex2lattice proc~hex2lattice->proc~xy_ordered_union proc~get_flake honeytools::get_flake proc~get_flake->proc~hex2lattice proc~get_stripe honeytools::get_stripe proc~get_stripe->proc~hex2lattice proc~get_supercell honeytools::get_supercell proc~get_supercell->proc~hex2lattice proc~get_triangle honeytools::get_triangle proc~get_triangle->proc~hex2lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code push_back Source Code pure subroutine push_back ( vec , val ) !! Poor man implementation of a dynamic !! array, a là std::vector (but without !! preallocation and smart doubling...) class ( xy_lattice ), intent ( inout ) :: vec type ( xy_site ), intent ( in ) :: val type ( xy_site ), allocatable :: tmp (:) integer :: len if ( allocated ( vec % site )) then len = size ( vec % site ) allocate ( tmp ( len + 1 )) tmp (: len ) = vec % site call move_alloc ( tmp , vec % site ) len = len + 1 else len = 1 allocate ( vec % site ( len )) end if !PUSH val at the BACK vec % site ( len ) = val !Increade formal size vec % size = len end subroutine push_back","tags":"","loc":"proc/push_back.html"},{"title":"xy_class_print – HoneyTools","text":"private impure elemental subroutine xy_class_print(S, unit, quiet) Pretty print of xy coordinates in static arrays Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: S integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false. Called by proc~~xy_class_print~~CalledByGraph proc~xy_class_print xy_coordinates::xy_class_print interface~xy_print xy_coordinates::xy_print interface~xy_print->proc~xy_class_print proc~xy_lattice_print xy_coordinates::xy_lattice_print interface~xy_print->proc~xy_lattice_print proc~xy_lattice_print->interface~xy_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_class_print.html"},{"title":"xy_lattice_print – HoneyTools","text":"private impure elemental subroutine xy_lattice_print(S, unit, quiet) Pretty print of xy coordinates in dynamic arrays Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: S integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false. Calls proc~~xy_lattice_print~~CallsGraph proc~xy_lattice_print xy_coordinates::xy_lattice_print interface~xy_print xy_coordinates::xy_print proc~xy_lattice_print->interface~xy_print interface~xy_print->proc~xy_lattice_print proc~xy_class_print xy_coordinates::xy_class_print interface~xy_print->proc~xy_class_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~xy_lattice_print~~CalledByGraph proc~xy_lattice_print xy_coordinates::xy_lattice_print interface~xy_print xy_coordinates::xy_print proc~xy_lattice_print->interface~xy_print interface~xy_print->proc~xy_lattice_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/xy_lattice_print.html"},{"title":"xy_print – HoneyTools","text":"public interface xy_print Calls interface~~xy_print~~CallsGraph interface~xy_print xy_coordinates::xy_print proc~xy_class_print xy_coordinates::xy_class_print interface~xy_print->proc~xy_class_print proc~xy_lattice_print xy_coordinates::xy_lattice_print interface~xy_print->proc~xy_lattice_print proc~xy_lattice_print->interface~xy_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~xy_print~~CalledByGraph interface~xy_print xy_coordinates::xy_print proc~xy_lattice_print xy_coordinates::xy_lattice_print interface~xy_print->proc~xy_lattice_print proc~xy_lattice_print->interface~xy_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures xy_class_print xy_lattice_print Module Procedures private impure elemental subroutine xy_class_print (S, unit, quiet) Pretty print of xy coordinates in static arrays Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: S integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false. private impure elemental subroutine xy_lattice_print (S, unit, quiet) Pretty print of xy coordinates in dynamic arrays Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: S integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false.","tags":"","loc":"interface/xy_print.html"},{"title":"get_supercell – HoneyTools","text":"public pure function get_supercell(rows, cols, layout) result(lattice) Get the lattice for a honeycomb supercell Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows integer, intent(in) :: cols type( unit_cell ), intent(in) :: layout Return Value type( xy_lattice ) Calls proc~~get_supercell~~CallsGraph proc~get_supercell honeytools::get_supercell proc~hex2lattice xy_coordinates::hex2lattice proc~get_supercell->proc~hex2lattice proc~hex_supercell hex_geometries::hex_supercell proc~get_supercell->proc~hex_supercell proc~hex2corner xy_coordinates::hex2corner proc~hex2lattice->proc~hex2corner proc~xy_ordered_union xy_coordinates::xy_ordered_union proc~hex2lattice->proc~xy_ordered_union proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset site site proc~hex2corner->site proc~push_back xy_coordinates::xy_lattice%push_back proc~xy_ordered_union->proc~push_back proc~xy_ordered_union->site origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur proc~push_back->site Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/get_supercell.html"},{"title":"get_triangle – HoneyTools","text":"public pure function get_triangle(size, layout) result(lattice) Get the lattice for a triangle-shaped flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: size type( unit_cell ), intent(in) :: layout Return Value type( xy_lattice ) Calls proc~~get_triangle~~CallsGraph proc~get_triangle honeytools::get_triangle proc~hex2lattice xy_coordinates::hex2lattice proc~get_triangle->proc~hex2lattice proc~hex_triangle hex_geometries::hex_triangle proc~get_triangle->proc~hex_triangle proc~hex2corner xy_coordinates::hex2corner proc~hex2lattice->proc~hex2corner proc~xy_ordered_union xy_coordinates::xy_ordered_union proc~hex2lattice->proc~xy_ordered_union assert assert proc~hex_triangle->assert proc~hex_insert hex_geometries::hex_insert proc~hex_triangle->proc~hex_insert proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset site site proc~hex2corner->site proc~push_back xy_coordinates::xy_lattice%push_back proc~xy_ordered_union->proc~push_back proc~xy_ordered_union->site origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur proc~push_back->site Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/get_triangle.html"},{"title":"get_flake – HoneyTools","text":"public pure function get_flake(radius, layout) result(lattice) Get the lattice for a hexagon-shaped flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: radius type( unit_cell ), intent(in) :: layout Return Value type( xy_lattice ) Calls proc~~get_flake~~CallsGraph proc~get_flake honeytools::get_flake proc~hex2lattice xy_coordinates::hex2lattice proc~get_flake->proc~hex2lattice proc~hex_flake hex_geometries::hex_flake proc~get_flake->proc~hex_flake proc~hex2corner xy_coordinates::hex2corner proc~hex2lattice->proc~hex2corner proc~xy_ordered_union xy_coordinates::xy_ordered_union proc~hex2lattice->proc~xy_ordered_union proc~hex_insert hex_geometries::hex_insert proc~hex_flake->proc~hex_insert proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset site site proc~hex2corner->site proc~push_back xy_coordinates::xy_lattice%push_back proc~xy_ordered_union->proc~push_back proc~xy_ordered_union->site origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur proc~push_back->site Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/get_flake.html"},{"title":"get_stripe – HoneyTools","text":"public pure function get_stripe(height, width, layout) result(lattice) Get the lattice for a hexagon-shaped flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: height integer, intent(in) :: width type( unit_cell ), intent(in) :: layout Return Value type( xy_lattice ) Calls proc~~get_stripe~~CallsGraph proc~get_stripe honeytools::get_stripe proc~hex2lattice xy_coordinates::hex2lattice proc~get_stripe->proc~hex2lattice proc~hex_armchair_stripe hex_geometries::hex_armchair_stripe proc~get_stripe->proc~hex_armchair_stripe proc~hex_zigzag_stripe hex_geometries::hex_zigzag_stripe proc~get_stripe->proc~hex_zigzag_stripe proc~hex2corner xy_coordinates::hex2corner proc~hex2lattice->proc~hex2corner proc~xy_ordered_union xy_coordinates::xy_ordered_union proc~hex2lattice->proc~xy_ordered_union proc~hex_insert hex_geometries::hex_insert proc~hex_armchair_stripe->proc~hex_insert proc~hex_zigzag_stripe->proc~hex_insert proc~hex2center xy_coordinates::hex2center proc~hex2corner->proc~hex2center proc~ith_corner_offset xy_coordinates::ith_corner_offset proc~hex2corner->proc~ith_corner_offset site site proc~hex2corner->site proc~push_back xy_coordinates::xy_lattice%push_back proc~xy_ordered_union->proc~push_back proc~xy_ordered_union->site origin origin proc~hex2center->origin uq uq proc~hex2center->uq ur ur proc~hex2center->ur proc~push_back->site Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents","tags":"","loc":"proc/get_stripe.html"},{"title":"hex_layout – HoneyTools","text":"Defining hexagonal unit-cells Used by module~~hex_layout~~UsedByGraph module~hex_layout hex_layout module~hex_geometries hex_geometries module~hex_geometries->module~hex_layout module~honeyplots honeyplots module~honeyplots->module~hex_layout module~xy_coordinates xy_coordinates module~honeyplots->module~xy_coordinates module~xy_neighbors xy_neighbors module~honeyplots->module~xy_neighbors module~honeytools honeytools module~honeytools->module~hex_layout module~honeytools->module~hex_geometries module~honeytools->module~xy_coordinates module~honeytools->module~xy_neighbors module~xy_coordinates->module~hex_layout module~xy_neighbors->module~hex_layout module~xy_neighbors->module~xy_coordinates Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables armchair zigzag aq ar zq zr Derived Types hex_orientation unit_cell Functions orientation_equality Subroutines print_unit_cell Variables Type Visibility Attributes Name Initial type( hex_orientation ), public, parameter :: armchair = hex_orientation(aq, ar, 0d0) type( hex_orientation ), public, parameter :: zigzag = hex_orientation(zq, zr, 0.5d0) real(kind=8), private, parameter,               dimension(2) :: aq = [3d0/2d0, sqrt(3d0)/2d0] real(kind=8), private, parameter,               dimension(2) :: ar = [0d0, sqrt(3d0)] real(kind=8), private, parameter,               dimension(2) :: zq = [sqrt(3d0), 0d0] real(kind=8), private, parameter,               dimension(2) :: zr = [sqrt(3d0)/2d0, 3d0/2d0] Derived Types type, public :: hex_orientation lattice-orientation data storage Components Type Visibility Attributes Name Initial real(kind=8), public, dimension(2) :: uq 1st unit-vector real(kind=8), public, dimension(2) :: ur 2nd unit-vector real(kind=8), public :: angle in units of 60° Type-Bound Procedures generic,\n                  public\n,                   :: operator(==) => orientation_equality procedure\n                    ,                  private\n                  :: orientation_equality Function type, public :: unit_cell Wrapper type to define all about a honeycomb structure Components Type Visibility Attributes Name Initial type( hex_orientation ), public :: orientation armchair or zigzag real(kind=8), public :: size = 1d0 lattice parameter real(kind=8), public, dimension(2) :: origin = [0d0, 0d0] Type-Bound Procedures procedure\n                    ,                  public\n,                   :: print => print_unit_cell Subroutine call layout%print Functions private pure function orientation_equality (a, b) result(isequal) Overload of == operator for hex_orientation type Arguments Type Intent Optional Attributes Name class( hex_orientation ), intent(in) :: a class( hex_orientation ), intent(in) :: b Return Value logical Subroutines public impure elemental subroutine print_unit_cell (C, unit) Pretty print of hex coordinates Arguments Type Intent Optional Attributes Name class( unit_cell ), intent(in) :: C integer, intent(in), optional :: unit default = $stdout","tags":"","loc":"module/hex_layout.html"},{"title":"hex_coordinates – HoneyTools","text":"Defining special 3D coordinates for honeycomb lattices Uses assert_m module~~hex_coordinates~~UsesGraph module~hex_coordinates hex_coordinates assert_m assert_m module~hex_coordinates->assert_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hex_coordinates~~UsedByGraph module~hex_coordinates hex_coordinates module~hex_geometries hex_geometries module~hex_geometries->module~hex_coordinates module~hex_neighbors hex_neighbors module~hex_neighbors->module~hex_coordinates module~honeyplots honeyplots module~honeyplots->module~hex_coordinates module~honeyplots->module~hex_neighbors module~xy_coordinates xy_coordinates module~honeyplots->module~xy_coordinates module~xy_neighbors xy_neighbors module~honeyplots->module~xy_neighbors module~honeytools honeytools module~honeytools->module~hex_coordinates module~honeytools->module~hex_geometries module~honeytools->module~hex_neighbors module~honeytools->module~xy_coordinates module~honeytools->module~xy_neighbors module~xy_coordinates->module~hex_coordinates module~xy_neighbors->module~xy_coordinates Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces hex operator(==) operator(/=) operator(+) operator(-) operator(*) Derived Types hex Functions hex_norm hex_distance new_hex_cubic new_hex_axial eq_hex neq_hex add_hex sub_hex rhs_hex lhs_hex dot_hex Subroutines hex_print Interfaces public        interface hex constructor override private pure function new_hex_cubic (q, r, s) result(H) Safe cubic constructor for the hex type\nfeaturing an assertion on input coordinates\nbefore the initialization of the object Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r integer, intent(in) :: s Return Value type( hex ) private pure function new_hex_axial (q, r) result(H) Axial cubic constructor for the hex type\n[s would be computed internally] Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r Return Value type( hex ) public        interface operator(==) equality overload private pure elemental function eq_hex (A, B) result(isequal) Equality overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value logical public        interface operator(/=) inequality overload private pure elemental function neq_hex (A, B) result(notequal) Inequality overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value logical public        interface operator(+) addition overload private pure elemental function add_hex (A, B) result(C) Addition overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex ) public        interface operator(-) subtraction overload private pure elemental function sub_hex (A, B) result(C) Subtraction overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex ) public        interface operator(*) product overload private pure elemental function rhs_hex (A, k) result(C) Right scale overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A integer, intent(in) :: k Return Value type( hex ) private pure elemental function lhs_hex (k, B) result(C) Left scale overload for hex type Arguments Type Intent Optional Attributes Name integer, intent(in) :: k type( hex ), intent(in) :: B Return Value type( hex ) private pure elemental function dot_hex (A, B) result(C) Dot overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value integer Derived Types type, public :: hex cubic coordinates for hexagonal tiles Components Type Visibility Attributes Name Initial integer, public :: q constrained by q+r+s==0 integer, public :: r constrained by q+r+s==0 integer, public :: s constrained by q+r+s==0 Constructor constructor override private\n\n                    pure\n                    function new_hex_cubic (q, r, s) Safe cubic constructor for the hex type\nfeaturing an assertion on input coordinates\nbefore the initialization of the object private\n\n                    pure\n                    function new_hex_axial (q, r) Axial cubic constructor for the hex type\n[s would be computed internally] Functions public pure function hex_norm (H) result(n) Taxicab norm from hex coordinates Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: H Return Value integer public pure function hex_distance (A, B) result(d) Taxicab distance of hex coordinates Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value integer private pure function new_hex_cubic (q, r, s) result(H) Safe cubic constructor for the hex type\nfeaturing an assertion on input coordinates\nbefore the initialization of the object Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r integer, intent(in) :: s Return Value type( hex ) private pure function new_hex_axial (q, r) result(H) Axial cubic constructor for the hex type\n[s would be computed internally] Arguments Type Intent Optional Attributes Name integer, intent(in) :: q integer, intent(in) :: r Return Value type( hex ) private pure elemental function eq_hex (A, B) result(isequal) Equality overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value logical private pure elemental function neq_hex (A, B) result(notequal) Inequality overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value logical private pure elemental function add_hex (A, B) result(C) Addition overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex ) private pure elemental function sub_hex (A, B) result(C) Subtraction overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex ) private pure elemental function rhs_hex (A, k) result(C) Right scale overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A integer, intent(in) :: k Return Value type( hex ) private pure elemental function lhs_hex (k, B) result(C) Left scale overload for hex type Arguments Type Intent Optional Attributes Name integer, intent(in) :: k type( hex ), intent(in) :: B Return Value type( hex ) private pure elemental function dot_hex (A, B) result(C) Dot overload for hex type Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value integer Subroutines public impure elemental subroutine hex_print (H, unit, quiet) Pretty print of hex coordinates Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: H integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false.","tags":"","loc":"module/hex_coordinates.html"},{"title":"xy_neighbors – HoneyTools","text":"Defining all neighbors shells for given xy lattices Uses hex_layout xy_coordinates stdlib_sorting module~~xy_neighbors~~UsesGraph module~xy_neighbors xy_neighbors module~hex_layout hex_layout module~xy_neighbors->module~hex_layout module~xy_coordinates xy_coordinates module~xy_neighbors->module~xy_coordinates stdlib_sorting stdlib_sorting module~xy_neighbors->stdlib_sorting module~xy_coordinates->module~hex_layout assert_m assert_m module~xy_coordinates->assert_m module~hex_coordinates hex_coordinates module~xy_coordinates->module~hex_coordinates module~hex_coordinates->assert_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~xy_neighbors~~UsedByGraph module~xy_neighbors xy_neighbors module~honeyplots honeyplots module~honeyplots->module~xy_neighbors module~honeytools honeytools module~honeytools->module~xy_neighbors Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables N PI Functions xy_nn_hop xy_nnn_hop ith_A_offset ith_B_offset Subroutines xy_nearest_neighbors xy_next_nearest_neighbors xy_shells Variables Type Visibility Attributes Name Initial integer, private, parameter :: N = 6 real(kind=8), private, parameter :: PI = 4d0*atan(1d0) Functions public pure function xy_nn_hop (layout, S, i) result(Ni) Return the nearest neighbor of a lattice site, by hopping in\nthe i-th direction. You can feed any i ∈ ℤ, but you can get\nonly 3 inequivalent neighbors, depending on the label of the\ngiven site: \"A\" and \"B\" activate two different suitable sets\nof hopping directions. A lattice layout is required to build\nthe concrete hopping vectors. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( xy_site ), intent(in) :: S integer, intent(in) :: i Return Value type( xy_site ) public pure function xy_nnn_hop (layout, S, i) result(Ni) Return the i-th next-nearest neighbor of a lattice site, by\ntaking two xy_nn_hops in the suitable direction.\nYou can feed any i ∈ ℤ, but you can get only 6 inequivalent\nneighbors, depending on the label of the given site:\n\"A\" and \"B\" activate two different suitable sets of NN hops,\nA lattice layout is required to build the concrete hoppings. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( xy_site ), intent(in) :: S integer, intent(in) :: i Return Value type( xy_site ) private pure function ith_A_offset (layout, i) result(offset) Compute the offset vector connecting a site with label \"A\",\nto its i-th neighbor, returning a (scalar) xy coordinate.\nIt takes any i ∈ ℤ, but there will only be 3 inequivalent\noutput vectors, pointing to the three nearest neighbors. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout integer, intent(in) :: i Return Value type( xy ) private pure function ith_B_offset (layout, i) result(offset) Compute the offset vector connecting a site with label \"B\",\nto its i-th neighbor, returning a (scalar) xy coordinate.\nIt takes any i ∈ ℤ, but there will only be 3 inequivalent\noutput vectors, pointing to the three nearest neighbors. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout integer, intent(in) :: i Return Value type( xy ) Subroutines public pure subroutine xy_nearest_neighbors (lattice, nn_mask) Build a mask for the nearest neighbors of a given\nlattice. It is a NxN matrix, with N the number of\nsites in the lattice, stocking .true. values only\nfor the pairs of sites linked by a \"NN-bond\".\nIt calls internally xy_shells, for all inter-site\ndistances, so if you need more than NNs consider\ncalling xy_shells directly. Note that we provide\na similar subroutine for next-nearest-neighbors,\nwhich optionally gives also the NNs, so if just\ntwo shells are needed you should call that. Read more… Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice logical, intent(out), allocatable :: nn_mask (:,:) public pure subroutine xy_next_nearest_neighbors (lattice, nnn_mask, nn_mask) Build a mask for the next-nearest neighbors of a given lattice.\nIt is a NxN matrix, with N the number of sites in the lattice,\nstoring .true. values only for the pairs of sites linked by a\n\"NNN-bond\". Optionally builds a nearest-neighbors mask, too.\nIt calls internally xy_shells, for all inter-site\ndistances, so if you need more than NNNs consider\ncalling xy_shells directly. Note that we provide\na similar subroutine for nearest-neighbors only,\nso if you just need NNs consider calling it. Read more… Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice logical, intent(out), allocatable :: nnn_mask (:,:) logical, intent(out), optional, allocatable :: nn_mask (:,:) public pure subroutine xy_shells (lattice, shell_table, distance_set) Build a /ordered/ set of all inter-atomic distances\nin a given xy_lattice and a table storing distances\namong all sites. Searching this matrix for the n-th\nset entry gives a mask of all pairs of atomic sites\nthat are n-th order neigbors.\nE.g. shell_table == distance_set(1) would provide a\nmask for nearest neighbors, from which we can build\nthe tight-binding hopping term of the corresponding\nlattice hamiltonian. Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice real(kind=8), intent(out), allocatable :: shell_table (:,:) real(kind=8), intent(out), allocatable :: distance_set (:)","tags":"","loc":"module/xy_neighbors.html"},{"title":"hex_neighbors – HoneyTools","text":"Defining nearest neighbors for given hex coordinates Uses hex_coordinates module~~hex_neighbors~~UsesGraph module~hex_neighbors hex_neighbors module~hex_coordinates hex_coordinates module~hex_neighbors->module~hex_coordinates assert_m assert_m module~hex_coordinates->assert_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hex_neighbors~~UsedByGraph module~hex_neighbors hex_neighbors module~honeyplots honeyplots module~honeyplots->module~hex_neighbors module~honeytools honeytools module~honeytools->module~hex_neighbors Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables N Functions hex_direction hex_hop hex_nearest Variables Type Visibility Attributes Name Initial integer, private, parameter :: N = 6 Functions public pure function hex_direction (idir) result(dir) Return a direction in pseudo-3D hex space, given a (signed) integer label Arguments Type Intent Optional Attributes Name integer, intent(in) :: idir Return Value type( hex ) public pure function hex_hop (H, i) result(Ni) Return the nearest neighbor of H, \nby hopping in the i-th direction.\nYou can feed any i ∈ ℤ, but you'd\nget only 6 inequivalent neighbors Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: H integer, intent(in) :: i Return Value type( hex ) public pure function hex_nearest (H) result(nnvec) Return the vector of all nearest hex_neighbors of hex H Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: H Return Value type( hex ), dimension(N)","tags":"","loc":"module/hex_neighbors.html"},{"title":"honeyplots – HoneyTools","text":"Providing plotting facilities for hex tessellations Uses hex_coordinates hex_neighbors pyplot_module hex_layout xy_coordinates ogpf xy_neighbors module~~honeyplots~~UsesGraph module~honeyplots honeyplots module~hex_coordinates hex_coordinates module~honeyplots->module~hex_coordinates module~hex_layout hex_layout module~honeyplots->module~hex_layout module~hex_neighbors hex_neighbors module~honeyplots->module~hex_neighbors module~xy_coordinates xy_coordinates module~honeyplots->module~xy_coordinates module~xy_neighbors xy_neighbors module~honeyplots->module~xy_neighbors ogpf ogpf module~honeyplots->ogpf pyplot_module pyplot_module module~honeyplots->pyplot_module assert_m assert_m module~hex_coordinates->assert_m module~hex_neighbors->module~hex_coordinates module~xy_coordinates->module~hex_coordinates module~xy_coordinates->module~hex_layout module~xy_coordinates->assert_m module~xy_neighbors->module~hex_layout module~xy_neighbors->module~xy_coordinates stdlib_sorting stdlib_sorting module~xy_neighbors->stdlib_sorting Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables N Interfaces plot Subroutines xy_plot hex_plot Variables Type Visibility Attributes Name Initial integer, private, parameter :: N = 6 Interfaces public        interface plot public  subroutine xy_plot (lattice, nn_mask, nnn_mask, backend, figure_name, script_name, set_terminal) CURRENTLY GNUPLOT DOES NOT SUPPORT NN AND NNN LINKS, HELP IS WELCOME!\nSimple plotter for class(xy_lattice) objects. If optional argument nn_mask\nis passed it draws the nearest-neighbor bonds too. Similarly, if optional\nargument nnn_mask is passed a dashed link to next-nearest neighbors would\nbe drawed. Otherwise only lallice sites. It features two backends, giving\naccess to either matplotlib(pyplot) or gnuplot internal machinery. Either\nlibrary needs to be installed in your system for hex_plot to work.\nYou can specify a figure_name to save the plot to disk. If not specified\nthe plot would be just displayed in a popup window (or the terminal with\nsuitable configuration of the gnuplot backend) and a corresponding script\nsaved, aiming at fast reproduction (the script will all contain data).\nThe script has a default name (hex_plot.{py,gp}), but you can optionally\ngive your own custom string, do not forget the appropriate file extension.\nRegarding output formats instead, the two backends have slightly different\nbehavior: pyplot would infer the format from the given file extension in\nfigure_name, whilst gnuplot does need a proper \"output terminal\" to be set.\nYou can do that by passing the optional set_parameter variable. Refer to\noriginal gnuplot documentation for the list of available terminals and how\nthey should be chosen. For convenience we report that you can get the list\nof (system dependent) available terminals in your console by executing the\ngnuplot -e \"set terminal\" command in your shell. Furthermore all systems\nshould be compatible with the \"dumb\" terminal option, which would direct\nthe plot to the terminal itself, in the form of ASCII art. This can be\nvery useful for HPC workflows. Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice logical, intent(in), optional, allocatable :: nn_mask (:,:) logical, intent(in), optional, allocatable :: nnn_mask (:,:) character(len=*), intent(in), optional :: backend default: \"pyplot\" (or \"gnuplot\") character(len=*), intent(in), optional :: figure_name character(len=*), intent(in), optional :: script_name character(len=*), intent(in), optional :: set_terminal relevant to gnuplot backend public  subroutine hex_plot (layout, hexagons, backend, figure_name, script_name, set_terminal) Simple plotter for arrays of type(hex). It features two backends, giving\naccess to either matplotlib(pyplot) or gnuplot internal machinery. Either\nlibrary needs to be installed in your system for hex_plot to work.\nYou can specify a figure_name to save the plot to disk. If not specified\nthe plot would be just displayed in a popup window (or the terminal with\nsuitable configuration of the gnuplot backend) and a corresponding script\nsaved, aiming at fast reproduction (the script will all contain data).\nThe script has a default name (hex_plot.{py,gp}), but you can optionally\ngive your own custom string, do not forget the appropriate file extension.\nRegarding output formats instead, the two backends have slightly different\nbehavior: pyplot would infer the format from the given file extension in\nfigure_name, whilst gnuplot does need a proper \"output terminal\" to be set.\nYou can do that by passing the optional set_parameter variable. Refer to\noriginal gnuplot documentation for the list of available terminals and how\nthey should be chosen. For convenience we report that you can get the list\nof (system dependent) available terminals in your console by executing the\ngnuplot -e \"set terminal\" command in your shell. Furthermore all systems\nshould be compatible with the \"dumb\" terminal option, which would direct\nthe plot to the terminal itself, in the form of ASCII art. This can be\nvery useful for HPC workflows. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: hexagons (:) character(len=*), intent(in), optional :: backend default: \"pyplot\" (or \"gnuplot\") character(len=*), intent(in), optional :: figure_name character(len=*), intent(in), optional :: script_name character(len=*), intent(in), optional :: set_terminal relevant to gnuplot backend Subroutines public  subroutine xy_plot (lattice, nn_mask, nnn_mask, backend, figure_name, script_name, set_terminal) CURRENTLY GNUPLOT DOES NOT SUPPORT NN AND NNN LINKS, HELP IS WELCOME!\nSimple plotter for class(xy_lattice) objects. If optional argument nn_mask\nis passed it draws the nearest-neighbor bonds too. Similarly, if optional\nargument nnn_mask is passed a dashed link to next-nearest neighbors would\nbe drawed. Otherwise only lallice sites. It features two backends, giving\naccess to either matplotlib(pyplot) or gnuplot internal machinery. Either\nlibrary needs to be installed in your system for hex_plot to work.\nYou can specify a figure_name to save the plot to disk. If not specified\nthe plot would be just displayed in a popup window (or the terminal with\nsuitable configuration of the gnuplot backend) and a corresponding script\nsaved, aiming at fast reproduction (the script will all contain data).\nThe script has a default name (hex_plot.{py,gp}), but you can optionally\ngive your own custom string, do not forget the appropriate file extension.\nRegarding output formats instead, the two backends have slightly different\nbehavior: pyplot would infer the format from the given file extension in\nfigure_name, whilst gnuplot does need a proper \"output terminal\" to be set.\nYou can do that by passing the optional set_parameter variable. Refer to\noriginal gnuplot documentation for the list of available terminals and how\nthey should be chosen. For convenience we report that you can get the list\nof (system dependent) available terminals in your console by executing the\ngnuplot -e \"set terminal\" command in your shell. Furthermore all systems\nshould be compatible with the \"dumb\" terminal option, which would direct\nthe plot to the terminal itself, in the form of ASCII art. This can be\nvery useful for HPC workflows. Read more… Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice logical, intent(in), optional, allocatable :: nn_mask (:,:) logical, intent(in), optional, allocatable :: nnn_mask (:,:) character(len=*), intent(in), optional :: backend default: \"pyplot\" (or \"gnuplot\") character(len=*), intent(in), optional :: figure_name character(len=*), intent(in), optional :: script_name character(len=*), intent(in), optional :: set_terminal relevant to gnuplot backend public  subroutine hex_plot (layout, hexagons, backend, figure_name, script_name, set_terminal) Simple plotter for arrays of type(hex). It features two backends, giving\naccess to either matplotlib(pyplot) or gnuplot internal machinery. Either\nlibrary needs to be installed in your system for hex_plot to work.\nYou can specify a figure_name to save the plot to disk. If not specified\nthe plot would be just displayed in a popup window (or the terminal with\nsuitable configuration of the gnuplot backend) and a corresponding script\nsaved, aiming at fast reproduction (the script will all contain data).\nThe script has a default name (hex_plot.{py,gp}), but you can optionally\ngive your own custom string, do not forget the appropriate file extension.\nRegarding output formats instead, the two backends have slightly different\nbehavior: pyplot would infer the format from the given file extension in\nfigure_name, whilst gnuplot does need a proper \"output terminal\" to be set.\nYou can do that by passing the optional set_parameter variable. Refer to\noriginal gnuplot documentation for the list of available terminals and how\nthey should be chosen. For convenience we report that you can get the list\nof (system dependent) available terminals in your console by executing the\ngnuplot -e \"set terminal\" command in your shell. Furthermore all systems\nshould be compatible with the \"dumb\" terminal option, which would direct\nthe plot to the terminal itself, in the form of ASCII art. This can be\nvery useful for HPC workflows. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: hexagons (:) character(len=*), intent(in), optional :: backend default: \"pyplot\" (or \"gnuplot\") character(len=*), intent(in), optional :: figure_name character(len=*), intent(in), optional :: script_name character(len=*), intent(in), optional :: set_terminal relevant to gnuplot backend","tags":"","loc":"module/honeyplots.html"},{"title":"hex_geometries – HoneyTools","text":"Provide common honeycomb geometries, as dynamic type(hex) arrays Uses hex_coordinates hex_layout assert_m module~~hex_geometries~~UsesGraph module~hex_geometries hex_geometries assert_m assert_m module~hex_geometries->assert_m module~hex_coordinates hex_coordinates module~hex_geometries->module~hex_coordinates module~hex_layout hex_layout module~hex_geometries->module~hex_layout module~hex_coordinates->assert_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hex_geometries~~UsedByGraph module~hex_geometries hex_geometries module~honeytools honeytools module~honeytools->module~hex_geometries Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions hex_supercell hex_triangle hex_flake hex_armchair_stripe hex_zigzag_stripe hex_line linear_interpolation hex_round Subroutines hex_insert Functions public pure function hex_supercell (rows, cols) result(hexagons) Build a honeycomb supercell (parallelogram) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows integer, intent(in) :: cols Return Value type( hex ), (rows*cols) public pure function hex_triangle (size) result(hexagons) Build a triangle-shaped honeycomb flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: size Return Value type( hex ), allocatable, (:) public pure function hex_flake (radius) result(hexagons) Build a hexagon-shaped honeycomb flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: radius Return Value type( hex ), allocatable, (:) public pure function hex_armchair_stripe (height, width) result(hexagons) Build a armchair-on-top honeycomb stripe/ribbon\nCONVERSION TO XY SITES REQUIRES ARMCHAIR LAYOUT Arguments Type Intent Optional Attributes Name integer, intent(in) :: height integer, intent(in) :: width Return Value type( hex ), allocatable, (:) public pure function hex_zigzag_stripe (height, width) result(hexagons) Build a zigzag-on-top honeycomb stripe/ribbon\nCONVERSION TO XY SITES REQUIRES ZIGZAG LAYOUT Arguments Type Intent Optional Attributes Name integer, intent(in) :: height integer, intent(in) :: width Return Value type( hex ), allocatable, (:) public pure function hex_line (A, B) result(line) Draw a line between A and B, in hex space Arguments Type Intent Optional Attributes Name type( hex ), intent(in) :: A type( hex ), intent(in) :: B Return Value type( hex ), allocatable, (:) private pure elemental function linear_interpolation (a, b, t) result(l) Linear interpolation from a to b, with step t\na + (b - a) * t = a * (1-t) + b * t\nfor better floating-point precision Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: t Return Value real(kind=8) private pure function hex_round (xyz) result(qrs) Round a triplet of reals to a proper hex object Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: xyz (3) Return Value type( hex ) Subroutines public pure subroutine hex_insert (vec, val) Utility to grow type(hex) arrays, it is a\npoor man implementation of a dynamic array\ninsertion, a là std::vector (but with no\npreallocation and smart doubling...) Arguments Type Intent Optional Attributes Name type( hex ), intent(inout), allocatable :: vec (:) type( hex ), intent(in) :: val","tags":"","loc":"module/hex_geometries.html"},{"title":"xy_coordinates – HoneyTools","text":"Defining real space 2D coordinates for honeycomb lattice sites Uses hex_coordinates hex_layout assert_m module~~xy_coordinates~~UsesGraph module~xy_coordinates xy_coordinates assert_m assert_m module~xy_coordinates->assert_m module~hex_coordinates hex_coordinates module~xy_coordinates->module~hex_coordinates module~hex_layout hex_layout module~xy_coordinates->module~hex_layout module~hex_coordinates->assert_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~xy_coordinates~~UsedByGraph module~xy_coordinates xy_coordinates module~honeyplots honeyplots module~honeyplots->module~xy_coordinates module~xy_neighbors xy_neighbors module~honeyplots->module~xy_neighbors module~honeytools honeytools module~honeytools->module~xy_coordinates module~honeytools->module~xy_neighbors module~xy_neighbors->module~xy_coordinates Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables N PI Interfaces xy_print Derived Types xy xy_site xy_lattice Functions xy_distance hex2site hex2corner hex2center hex2lattice get_sublattice xy_ordered_union ith_corner_offset eq_xy neq_xy eq_lattice neq_lattice xy_norm Subroutines push_back xy_class_print xy_lattice_print Variables Type Visibility Attributes Name Initial integer, private, parameter :: N = 6 real(kind=8), private, parameter :: PI = 4d0*atan(1d0) Interfaces public        interface xy_print private impure elemental subroutine xy_class_print (S, unit, quiet) Pretty print of xy coordinates in static arrays Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: S integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false. private impure elemental subroutine xy_lattice_print (S, unit, quiet) Pretty print of xy coordinates in dynamic arrays Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: S integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false. Derived Types type, public :: xy Base type for 2D points Components Type Visibility Attributes Name Initial real(kind=8), public :: x real(kind=8), public :: y Type-Bound Procedures generic,\n                  public\n,                   :: operator(==) => eq_xy generic,\n                  public\n,                   :: operator(/=) => neq_xy procedure\n                    ,                  private\n                  :: eq_xy Function procedure\n                    ,                  private\n                  :: neq_xy Function type, public, extends( xy ) :: xy_site A 2D point extension for inequivalent sites Components Type Visibility Attributes Name Initial real(kind=8), public :: x real(kind=8), public :: y character(len=1), public :: label A or B (sublattice) integer, public :: key = 0 for lattice lookup Type-Bound Procedures generic,\n                  public\n,                   :: operator(==) => eq_xy generic,\n                  public\n,                   :: operator(/=) => neq_xy type, public :: xy_lattice Wrapper type for storing dynamically\nsized collections of lattice sites Components Type Visibility Attributes Name Initial type( xy_site ), public, allocatable :: site (:) integer, public :: size Type-Bound Procedures generic,\n                  public\n,                   :: operator(==) => eq_lattice generic,\n                  public\n,                   :: operator(/=) => neq_lattice procedure\n                    ,                  public\n,                   :: push_back Subroutine procedure\n                    ,                  private\n                  :: eq_lattice Function procedure\n                    ,                  private\n                  :: neq_lattice Function Functions public pure elemental function xy_distance (A, B) result(d) Polymorphic euclidean distance for xy class Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value real(kind=8) public pure elemental function hex2site (layout, H, label) result(site) Convert hex coordinates to real 2D lattice sites\n[returning the xy coordinates for the unique unit-cell,\n sites \"A\" and \"B\": this of course does not account for\n border effects, so would be suitable only for simple,\n periodized, systems, which for now are out of scope.]\nActual real-space layout has to be specified by passing\na (scalar) unit_cell object. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: H character(len=1), intent(in) :: label A or B Return Value type( xy_site ) public pure elemental function hex2corner (layout, H) result(corner) Convert hex coordinates to real 2D space\n[returning the xy coordinates for the hexagon corners,\n as appropriatiely wrapped in the \"xy_lattice\" type]\nActual real-space layout has to be specified by passing\na (scalar) unit_cell object. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: H Return Value type( xy_lattice ) public pure elemental function hex2center (layout, H) result(center) Convert hex coordinates to real 2D space\n[returning the xy coordinates of the hexagon center]\nActual real-space layout has to be specified by passing\na (scalar) unit_cell object. Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: H Return Value type( xy ) public pure function hex2lattice (layout, hexagons) result(lattice) Generate a type(xy_lattice) object from any given hex\narray, provided a suitable layout (unit-cell) Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout type( hex ), intent(in) :: hexagons (:) Return Value type( xy_lattice ) public pure elemental function get_sublattice (lattice, label) result(sublattice) Extract sublattice, given a lattice and a label (\"A\" or \"B\") Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: lattice character(len=1), intent(in) :: label A or B Return Value type( xy_lattice ) public pure function xy_ordered_union (A, B) result(C) An ordered-keys set union for xy_lattices.\nIt compares the lattice sites, looking at\ntheir x and y coordinates only: equal x,y\nentries are inserted in C just once, so to\nmake it a set. A and B must be sets too.\nThe sublattice labels are preserved in the\nprocess, assuming that two sites with the\nsame x,y pertain to the same sublattice.\nFor A the keys are assumed to be 1:size(A),\nand preserved as such (with an assertion).\nThe keys of B are instead discarded, so to\nbe replaced by size(A):size(C), which thus\namounts to have result C uniquely indexed\nas 1, 2, ... , size(A) + size(B).\nThis allows building consistently indexed\nmatrices to act on the lattice array, such\nas real-space tight-binding hamiltonians.\nThe keys would then be used to index other\nreal space quantities, such as LDOS, Chern\nmarker, local magnetization, and so on. Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: A type( xy_lattice ), intent(in) :: B Return Value type( xy_lattice ) private pure function ith_corner_offset (layout, i) result(offset) Compute the i-th offset vector connecting the hexagon center\nto its corners, returning a (scalar) xy coordinate Arguments Type Intent Optional Attributes Name type( unit_cell ), intent(in) :: layout integer, intent(in) :: i Return Value type( xy ) private pure elemental function eq_xy (A, B) result(isequal) tolerance equality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical private pure elemental function neq_xy (A, B) result(notequal) tolerance inequality for xy class\n[absolute tol hard-coded to 1d-12]\n-> probably to improve... Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A class( xy ), intent(in) :: B Return Value logical private pure elemental function eq_lattice (A, B) result(isequal) polymorphic equality overload for xy_lattice type Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(in) :: A class( xy_lattice ), intent(in) :: B Return Value logical private pure elemental function neq_lattice (A, B) result(notequal) polymorphic inequality overload for xy_lattice type Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(in) :: A class( xy_lattice ), intent(in) :: B Return Value logical private pure elemental function xy_norm (A) result(r) polymorphic euclidean norm for xy class Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: A Return Value real(kind=8) Subroutines private pure subroutine push_back (vec, val) Poor man implementation of a dynamic\narray, a là std::vector (but without\npreallocation and smart doubling...) Arguments Type Intent Optional Attributes Name class( xy_lattice ), intent(inout) :: vec type( xy_site ), intent(in) :: val private impure elemental subroutine xy_class_print (S, unit, quiet) Pretty print of xy coordinates in static arrays Arguments Type Intent Optional Attributes Name class( xy ), intent(in) :: S integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false. private impure elemental subroutine xy_lattice_print (S, unit, quiet) Pretty print of xy coordinates in dynamic arrays Arguments Type Intent Optional Attributes Name type( xy_lattice ), intent(in) :: S integer, intent(in), optional :: unit default = $stdout logical, intent(in), optional :: quiet default = .false.","tags":"","loc":"module/xy_coordinates.html"},{"title":"honeytools – HoneyTools","text":"Top level API: what you probably want to use Uses hex_coordinates hex_geometries hex_neighbors hex_layout xy_coordinates xy_neighbors module~~honeytools~~UsesGraph module~honeytools honeytools module~hex_coordinates hex_coordinates module~honeytools->module~hex_coordinates module~hex_geometries hex_geometries module~honeytools->module~hex_geometries module~hex_layout hex_layout module~honeytools->module~hex_layout module~hex_neighbors hex_neighbors module~honeytools->module~hex_neighbors module~xy_coordinates xy_coordinates module~honeytools->module~xy_coordinates module~xy_neighbors xy_neighbors module~honeytools->module~xy_neighbors assert_m assert_m module~hex_coordinates->assert_m module~hex_geometries->module~hex_coordinates module~hex_geometries->module~hex_layout module~hex_geometries->assert_m module~hex_neighbors->module~hex_coordinates module~xy_coordinates->module~hex_coordinates module~xy_coordinates->module~hex_layout module~xy_coordinates->assert_m module~xy_neighbors->module~hex_layout module~xy_neighbors->module~xy_coordinates stdlib_sorting stdlib_sorting module~xy_neighbors->stdlib_sorting Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Functions get_supercell get_triangle get_flake get_stripe Functions public pure function get_supercell (rows, cols, layout) result(lattice) Get the lattice for a honeycomb supercell Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows integer, intent(in) :: cols type( unit_cell ), intent(in) :: layout Return Value type( xy_lattice ) public pure function get_triangle (size, layout) result(lattice) Get the lattice for a triangle-shaped flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: size type( unit_cell ), intent(in) :: layout Return Value type( xy_lattice ) public pure function get_flake (radius, layout) result(lattice) Get the lattice for a hexagon-shaped flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: radius type( unit_cell ), intent(in) :: layout Return Value type( xy_lattice ) public pure function get_stripe (height, width, layout) result(lattice) Get the lattice for a hexagon-shaped flake Arguments Type Intent Optional Attributes Name integer, intent(in) :: height integer, intent(in) :: width type( unit_cell ), intent(in) :: layout Return Value type( xy_lattice )","tags":"","loc":"module/honeytools.html"},{"title":"hex_layout.f90 – HoneyTools","text":"Files dependent on this one sourcefile~~hex_layout.f90~~AfferentGraph sourcefile~hex_layout.f90 hex_layout.f90 sourcefile~hex_geometries.f90 hex_geometries.f90 sourcefile~hex_geometries.f90->sourcefile~hex_layout.f90 sourcefile~honeyplots.f90 honeyplots.f90 sourcefile~honeyplots.f90->sourcefile~hex_layout.f90 sourcefile~xy_coordinates.f90 xy_coordinates.f90 sourcefile~honeyplots.f90->sourcefile~xy_coordinates.f90 sourcefile~xy_neighbors.f90 xy_neighbors.f90 sourcefile~honeyplots.f90->sourcefile~xy_neighbors.f90 sourcefile~honeytools.f90 honeytools.f90 sourcefile~honeytools.f90->sourcefile~hex_layout.f90 sourcefile~honeytools.f90->sourcefile~hex_geometries.f90 sourcefile~honeytools.f90->sourcefile~xy_coordinates.f90 sourcefile~honeytools.f90->sourcefile~xy_neighbors.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_layout.f90 sourcefile~xy_neighbors.f90->sourcefile~hex_layout.f90 sourcefile~xy_neighbors.f90->sourcefile~xy_coordinates.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules hex_layout Source Code hex_layout.f90 Source Code module hex_layout !! Defining hexagonal unit-cells implicit none private public :: zigzag , armchair , unit_cell , print_unit_cell ! exp to top level public :: hex_orientation ! not to be exported to top level type hex_orientation !! lattice-orientation data storage real ( 8 ), dimension ( 2 ) :: uq !! 1st unit-vector real ( 8 ), dimension ( 2 ) :: ur !! 2nd unit-vector real ( 8 ) :: angle !! in units of 60° contains generic :: operator ( == ) => orientation_equality procedure , private :: orientation_equality end type ! Armchair unit-vectors: real ( 8 ), dimension ( 2 ), parameter :: aq = [ 3 d0 / 2 d0 , sqrt ( 3 d0 ) / 2 d0 ] real ( 8 ), dimension ( 2 ), parameter :: ar = [ 0 d0 , sqrt ( 3 d0 )] ! Zig-Zag unit-vectors: real ( 8 ), dimension ( 2 ), parameter :: zq = [ sqrt ( 3 d0 ), 0 d0 ] real ( 8 ), dimension ( 2 ), parameter :: zr = [ sqrt ( 3 d0 ) / 2 d0 , 3 d0 / 2 d0 ] ! Predefined orientations: type ( hex_orientation ), parameter :: armchair = hex_orientation ( aq , ar , 0 d0 ) type ( hex_orientation ), parameter :: zigzag = hex_orientation ( zq , zr , 0.5d0 ) type unit_cell !! Wrapper type to define all about a honeycomb structure !  Dev-note: may we put size(2) to enable anysotropy? type ( hex_orientation ) :: orientation !! armchair or zigzag real ( 8 ) :: size = 1 d0 !! lattice parameter real ( 8 ), dimension ( 2 ) :: origin = [ 0 d0 , 0 d0 ] contains procedure :: print => print_unit_cell !! call layout%print end type contains impure elemental subroutine print_unit_cell ( C , unit ) !! Pretty print of hex coordinates class ( unit_cell ), intent ( in ) :: C integer , intent ( in ), optional :: unit !! default = $stdout integer :: stdunit if ( present ( unit )) then stdunit = unit else stdunit = 6 ! stdout endif write ( stdunit , * ) \"HEXAGONAL UNIT-CELL\" if ( C % orientation == armchair ) then write ( stdunit , * ) \"Orientation: ARMCHAIR\" elseif ( C % orientation == zigzag ) then write ( stdunit , * ) \"Orientation: ZIGZAG\" else write ( stdunit , * ) \"Orientation: UNKNOWN\" end if write ( stdunit , * ) \"lattice parameter = \" , C % size write ( stdunit , * ) \"located at [\" , C % origin ( 1 ), C % origin ( 2 ), \"]\" write ( stdunit , * ) \"\" end subroutine pure function orientation_equality ( a , b ) result ( isequal ) !! Overload of == operator for hex_orientation type class ( hex_orientation ), intent ( in ) :: a , b logical :: isequal isequal = all ( abs ( a % uq - b % uq ) < 1 d - 12 ) isequal = isequal . and . all ( abs ( a % ur - b % ur ) < 1 d - 12 ) isequal = isequal . and . ( a % angle - b % angle ) < 1 d - 12 end function end module hex_layout","tags":"","loc":"sourcefile/hex_layout.f90.html"},{"title":"hex_coordinates.f90 – HoneyTools","text":"Files dependent on this one sourcefile~~hex_coordinates.f90~~AfferentGraph sourcefile~hex_coordinates.f90 hex_coordinates.f90 sourcefile~hex_geometries.f90 hex_geometries.f90 sourcefile~hex_geometries.f90->sourcefile~hex_coordinates.f90 sourcefile~hex_neighbors.f90 hex_neighbors.f90 sourcefile~hex_neighbors.f90->sourcefile~hex_coordinates.f90 sourcefile~honeyplots.f90 honeyplots.f90 sourcefile~honeyplots.f90->sourcefile~hex_coordinates.f90 sourcefile~honeyplots.f90->sourcefile~hex_neighbors.f90 sourcefile~xy_coordinates.f90 xy_coordinates.f90 sourcefile~honeyplots.f90->sourcefile~xy_coordinates.f90 sourcefile~xy_neighbors.f90 xy_neighbors.f90 sourcefile~honeyplots.f90->sourcefile~xy_neighbors.f90 sourcefile~honeytools.f90 honeytools.f90 sourcefile~honeytools.f90->sourcefile~hex_coordinates.f90 sourcefile~honeytools.f90->sourcefile~hex_geometries.f90 sourcefile~honeytools.f90->sourcefile~hex_neighbors.f90 sourcefile~honeytools.f90->sourcefile~xy_coordinates.f90 sourcefile~honeytools.f90->sourcefile~xy_neighbors.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_coordinates.f90 sourcefile~xy_neighbors.f90->sourcefile~xy_coordinates.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules hex_coordinates Source Code hex_coordinates.f90 Source Code module hex_coordinates !! Defining special 3D coordinates for honeycomb lattices use assert_m , only : assert ![pure assertion for new_hex_cubic] implicit none private public :: hex , hex_norm , hex_distance , hex_print public :: operator ( == ), operator ( /= ), operator ( + ), operator ( - ), operator ( * ) type hex !! cubic coordinates for hexagonal tiles integer :: q , r , s !! constrained by q+r+s==0 endtype interface hex !! constructor override procedure :: new_hex_cubic !(q,r,s) procedure :: new_hex_axial !(q,r) end interface interface operator ( == ) !! equality overload procedure :: eq_hex end interface interface operator ( /= ) !! inequality overload procedure :: neq_hex end interface interface operator ( + ) !! addition overload procedure :: add_hex end interface interface operator ( - ) !! subtraction overload procedure :: sub_hex end interface interface operator ( * ) !! product overload procedure :: rhs_hex procedure :: lhs_hex procedure :: dot_hex end interface contains ! PUBLIC API [private at bottom] pure function hex_norm ( H ) result ( n ) !! Taxicab norm from hex coordinates type ( hex ), intent ( in ) :: H integer :: n n = ( abs ( H % q ) + & abs ( H % r ) + & abs ( H % s )) / 2 end function pure function hex_distance ( A , B ) result ( d ) !! Taxicab distance of hex coordinates type ( hex ), intent ( in ) :: A , B integer :: d d = hex_norm ( A - B ) ! overloaded subtraction end function impure elemental subroutine hex_print ( H , unit , quiet ) !! Pretty print of hex coordinates type ( hex ), intent ( in ) :: H integer , intent ( in ), optional :: unit !! default = $stdout logical , intent ( in ), optional :: quiet !! default = .false. integer :: stdunit logical :: verbose if ( present ( quiet )) then verbose = . not . quiet else verbose = . true . endif if ( present ( unit )) then stdunit = unit else stdunit = 6 ! stdout endif if ( verbose ) then write ( stdunit , * ) \"hex coordinates [q,r,s]: \" , H % q , H % r , H % s else write ( stdunit , * ) H % q , H % r , H % s endif end subroutine ! THESE ARE PRIVATE NAMES pure function new_hex_cubic ( q , r , s ) result ( H ) !! Safe cubic constructor for the hex type integer , intent ( in ) :: q , r , s type ( hex ) :: H !> featuring an assertion on input coordinates call assert ( q + r + s == 0 , \"q + r + s == 0\" , q + r + s ) !> before the initialization of the object H % q = q H % r = r H % s = s end function pure function new_hex_axial ( q , r ) result ( H ) !! Axial cubic constructor for the hex type integer , intent ( in ) :: q , r type ( hex ) :: H H % q = q H % r = r !> [s would be computed internally] H % s = - q - r end function pure elemental function eq_hex ( A , B ) result ( isequal ) !! Equality overload for hex type type ( hex ), intent ( in ) :: A , B logical :: isequal isequal = A % q == B % q . and . & A % r == B % r . and . & A % s == B % s end function pure elemental function neq_hex ( A , B ) result ( notequal ) !! Inequality overload for hex type type ( hex ), intent ( in ) :: A , B logical :: notequal notequal = . not .( eq_hex ( A , B )) end function pure elemental function add_hex ( A , B ) result ( C ) !! Addition overload for hex type type ( hex ), intent ( in ) :: A , B type ( hex ) :: C C = hex ( q = A % q + B % q , & r = A % r + B % r , & s = A % s + B % s ) end function pure elemental function sub_hex ( A , B ) result ( C ) !! Subtraction overload for hex type type ( hex ), intent ( in ) :: A , B type ( hex ) :: C C = hex ( q = A % q - B % q , & r = A % r - B % r , & s = A % s - B % s ) end function pure elemental function rhs_hex ( A , k ) result ( C ) !! Right scale overload for hex type type ( hex ), intent ( in ) :: A integer , intent ( in ) :: k type ( hex ) :: C C = hex ( q = A % q * k , & r = A % r * k , & s = A % s * k ) end function pure elemental function lhs_hex ( k , B ) result ( C ) !! Left scale overload for hex type integer , intent ( in ) :: k type ( hex ), intent ( in ) :: B type ( hex ) :: C C = hex ( q = k * B % q , & r = k * B % r , & s = k * B % s ) end function pure elemental function dot_hex ( A , B ) result ( C ) !! Dot overload for hex type type ( hex ), intent ( in ) :: A , B integer :: C C = A % q * B % q + & A % r * B % r + & A % s * B % s end function end module hex_coordinates","tags":"","loc":"sourcefile/hex_coordinates.f90.html"},{"title":"xy_neighbors.f90 – HoneyTools","text":"This file depends on sourcefile~~xy_neighbors.f90~~EfferentGraph sourcefile~xy_neighbors.f90 xy_neighbors.f90 sourcefile~hex_layout.f90 hex_layout.f90 sourcefile~xy_neighbors.f90->sourcefile~hex_layout.f90 sourcefile~xy_coordinates.f90 xy_coordinates.f90 sourcefile~xy_neighbors.f90->sourcefile~xy_coordinates.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_layout.f90 sourcefile~hex_coordinates.f90 hex_coordinates.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_coordinates.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~xy_neighbors.f90~~AfferentGraph sourcefile~xy_neighbors.f90 xy_neighbors.f90 sourcefile~honeyplots.f90 honeyplots.f90 sourcefile~honeyplots.f90->sourcefile~xy_neighbors.f90 sourcefile~honeytools.f90 honeytools.f90 sourcefile~honeytools.f90->sourcefile~xy_neighbors.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules xy_neighbors Source Code xy_neighbors.f90 Source Code module xy_neighbors !! Defining all neighbors shells for given xy lattices use xy_coordinates use hex_layout use stdlib_sorting , only : sort !=> ord_sort (impure) implicit none private public xy_nearest_neighbors , xy_next_nearest_neighbors public xy_nn_hop , xy_nnn_hop , xy_shells integer , parameter :: N = 6 ! Number of vertices in a hexagon real ( 8 ), parameter :: PI = 4 d0 * atan ( 1 d0 ) ! π to selected kind contains ! PUBLIC API [private at bottom] pure function xy_nn_hop ( layout , S , i ) result ( Ni ) !! Return the nearest neighbor of a lattice site, by hopping in !! the i-th direction. You can feed any i ∈ ℤ, but you can get !! only 3 inequivalent neighbors, depending on the label of the !! given site: \"A\" and \"B\" activate two different suitable sets !! of hopping directions. A lattice layout is required to build !! the concrete hopping vectors. type ( unit_cell ), intent ( in ) :: layout type ( xy_site ), intent ( in ) :: S integer , intent ( in ) :: i type ( xy_site ) :: Ni type ( xy ) :: Oi select case ( S % label ) case ( \"A\" ) Oi = ith_A_offset ( layout , i ) Ni % label = \"B\" case ( \"B\" ) Oi = ith_B_offset ( layout , i ) Ni % label = \"A\" end select Ni % x = S % x + Oi % x Ni % y = S % y + Oi % y end function pure function xy_nnn_hop ( layout , S , i ) result ( Ni ) !! Return the i-th next-nearest neighbor of a lattice site, by !! taking two xy_nn_hops in the suitable direction. !! You can feed any i ∈ ℤ, but you can get only 6 inequivalent !! neighbors, depending on the label of the given site: !! \"A\" and \"B\" activate two different suitable sets of NN hops, !! A lattice layout is required to build the concrete hoppings. type ( unit_cell ), intent ( in ) :: layout type ( xy_site ), intent ( in ) :: S integer , intent ( in ) :: i type ( xy_site ) :: Ni type ( xy_site ) :: NN , tmp type ( xy_site ) :: NNN ( 2 ) integer :: j , counter NN = xy_nn_hop ( layout , S , i ) counter = 0 do j = 1 , 3 tmp = xy_nn_hop ( layout , NN , j + i - 1 ) if ( tmp /= S ) then counter = counter + 1 NNN ( counter ) = tmp endif enddo if ( modulo ( i , 2 ) == 1 ) then !  for i = ...,1,3,5,... NI = NNN ( 1 ) else !  for i = ...,2,4,6,... NI = NNN ( 2 ) endif end function pure subroutine xy_nearest_neighbors ( lattice , nn_mask ) !! Build a mask for the nearest neighbors of a given !! lattice. It is a NxN matrix, with N the number of !! sites in the lattice, stocking .true. values only !! for the pairs of sites linked by a \"NN-bond\". !! It calls internally xy_shells, for all inter-site !! distances, so if you need more than NNs consider !! calling xy_shells directly. Note that we provide !! a similar subroutine for next-nearest-neighbors, !! which optionally gives also the NNs, so if just !! two shells are needed you should call that. !! > xy_next_nearest_neighbors(lattice,nnn,[nn]) type ( xy_lattice ), intent ( in ) :: lattice logical , allocatable , intent ( out ) :: nn_mask (:,:) real ( 8 ), allocatable :: shell_table (:,:) real ( 8 ), allocatable :: shell (:) ! Build all shells call xy_shells ( lattice , shell_table , shell ) ! Select the first nn_mask = abs ( shell_table - shell ( 1 )) < 1 d - 12 end subroutine pure subroutine xy_next_nearest_neighbors ( lattice , nnn_mask , nn_mask ) !! Build a mask for the next-nearest neighbors of a given lattice. !! It is a NxN matrix, with N the number of sites in the lattice, !! storing .true. values only for the pairs of sites linked by a !! \"NNN-bond\". Optionally builds a nearest-neighbors mask, too. !! It calls internally xy_shells, for all inter-site !! distances, so if you need more than NNNs consider !! calling xy_shells directly. Note that we provide !! a similar subroutine for nearest-neighbors only, !! so if you just need NNs consider calling it. !! > call xy_nearest_neighbors(lattices,nn_maks) type ( xy_lattice ), intent ( in ) :: lattice logical , allocatable , intent ( out ) :: nnn_mask (:,:) logical , allocatable , intent ( out ), optional :: nn_mask (:,:) real ( 8 ), allocatable :: shell_table (:,:) real ( 8 ), allocatable :: shell (:) ! Build all shells call xy_shells ( lattice , shell_table , shell ) if ( present ( nn_mask )) then ! Select the NNs nn_mask = abs ( shell_table - shell ( 1 )) < 1 d - 12 endif ! Select the NNNs nnn_mask = abs ( shell_table - shell ( 2 )) < 1 d - 12 end subroutine pure subroutine xy_shells ( lattice , shell_table , distance_set ) !! Build a /ordered/ set of all inter-atomic distances !! in a given xy_lattice and a table storing distances !! among all sites. Searching this matrix for the n-th !! set entry gives a mask of all pairs of atomic sites !! that are n-th order neigbors. !! E.g. shell_table == distance_set(1) would provide a !! mask for nearest neighbors, from which we can build !! the tight-binding hopping term of the corresponding !! lattice hamiltonian. type ( xy_lattice ), intent ( in ) :: lattice real ( 8 ), allocatable , intent ( out ) :: distance_set (:) real ( 8 ), allocatable , intent ( out ) :: shell_table (:,:) real ( 8 ) :: distance type ( xy_site ) :: A , B integer :: L , i , j , k L = size ( lattice % site ) allocate ( shell_table ( L , L ), distance_set ( L ** 2 )) shell_table = 0 d0 ! init the shells distance_set = 0 d0 ! and the set k = 0 ! unique distance counter do i = 1 , L - 1 do j = i + 1 , L A = lattice % site ( i ) B = lattice % site ( j ) distance = xy_distance ( A , B ) shell_table ( i , j ) = distance shell_table ( j , i ) = distance if ( all ( abs ( distance_set - distance ) > 1 d - 12 )) then k = k + 1 distance_set ( k ) = distance end if enddo enddo ! Shrink the set to the actual required size: distance_set = pack ( distance_set , distance_set /= 0 d0 ) call sort ( distance_set ) end subroutine xy_shells ! THESE ARE PRIVATE NAMES pure function ith_A_offset ( layout , i ) result ( offset ) !! Compute the offset vector connecting a site with label \"A\", !! to its i-th neighbor, returning a (scalar) xy coordinate. !! It takes any i ∈ ℤ, but there will only be 3 inequivalent !! output vectors, pointing to the three nearest neighbors. type ( unit_cell ), intent ( in ) :: layout integer , intent ( in ) :: i type ( xy ) :: offset real ( 8 ) :: angle angle = 4 d0 * PI / N * ( layout % orientation % angle + i ) ! mixed math ok angle = angle + 2 d0 * pi / N * ( 1 - layout % orientation % angle ) !-----> 60°,180°,300°... offset = xy ( x = layout % size * cos ( angle ), y = layout % size * sin ( angle )) end function pure function ith_B_offset ( layout , i ) result ( offset ) !! Compute the offset vector connecting a site with label \"B\", !! to its i-th neighbor, returning a (scalar) xy coordinate. !! It takes any i ∈ ℤ, but there will only be 3 inequivalent !! output vectors, pointing to the three nearest neighbors. type ( unit_cell ), intent ( in ) :: layout integer , intent ( in ) :: i type ( xy ) :: offset real ( 8 ) :: angle angle = 4 d0 * PI / N * ( layout % orientation % angle + i ) ! mixed math ok angle = angle + 2 d0 * pi / N * ( 2 - layout % orientation % angle ) !-----> 120°,240°,360°... offset = xy ( x = layout % size * cos ( angle ), y = layout % size * sin ( angle )) end function end module xy_neighbors","tags":"","loc":"sourcefile/xy_neighbors.f90.html"},{"title":"hex_neighbors.f90 – HoneyTools","text":"This file depends on sourcefile~~hex_neighbors.f90~~EfferentGraph sourcefile~hex_neighbors.f90 hex_neighbors.f90 sourcefile~hex_coordinates.f90 hex_coordinates.f90 sourcefile~hex_neighbors.f90->sourcefile~hex_coordinates.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~hex_neighbors.f90~~AfferentGraph sourcefile~hex_neighbors.f90 hex_neighbors.f90 sourcefile~honeyplots.f90 honeyplots.f90 sourcefile~honeyplots.f90->sourcefile~hex_neighbors.f90 sourcefile~honeytools.f90 honeytools.f90 sourcefile~honeytools.f90->sourcefile~hex_neighbors.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules hex_neighbors Source Code hex_neighbors.f90 Source Code module hex_neighbors !! Defining nearest neighbors for given hex coordinates use hex_coordinates implicit none private public hex_direction , hex_hop , hex_nearest integer , parameter :: N = 6 ! Number of allowed directions contains pure function hex_direction ( idir ) result ( dir ) !! Return a direction in pseudo-3D hex space, given a (signed) integer label integer , intent ( in ) :: idir type ( hex ) :: dir type ( hex ), dimension ( N ) :: all_directions ! List of allowed directions all_directions = [ hex ( 1 , 0 , - 1 ), & hex ( 1 , - 1 , 0 ), & hex ( 0 , - 1 , 1 ), & hex ( - 1 , 0 , 1 ), & hex ( - 1 , 1 , 0 ), & hex ( 0 , 1 , - 1 )] dir = all_directions ( 1 + modulo ( N + modulo ( idir , N ), N )) ! this allows cycling: any signed integer is mapped to a valid i \\in [1,6] end function pure function hex_hop ( H , i ) result ( Ni ) !! Return the nearest neighbor of H, !! by hopping in the i-th direction. !! You can feed any i ∈ ℤ, but you'd !! get only 6 inequivalent neighbors type ( hex ), intent ( in ) :: H integer , intent ( in ) :: i type ( hex ) :: Ni Ni = H + hex_direction ( i ) end function pure function hex_nearest ( H ) result ( nnvec ) !! Return the vector of all nearest hex_neighbors of hex H type ( hex ), intent ( in ) :: H type ( hex ), dimension ( N ) :: nnvec integer :: i do i = 1 , N nnvec ( i ) = hex_hop ( H , i ) enddo end function end module hex_neighbors","tags":"","loc":"sourcefile/hex_neighbors.f90.html"},{"title":"honeyplots.f90 – HoneyTools","text":"This file depends on sourcefile~~honeyplots.f90~~EfferentGraph sourcefile~honeyplots.f90 honeyplots.f90 sourcefile~hex_coordinates.f90 hex_coordinates.f90 sourcefile~honeyplots.f90->sourcefile~hex_coordinates.f90 sourcefile~hex_layout.f90 hex_layout.f90 sourcefile~honeyplots.f90->sourcefile~hex_layout.f90 sourcefile~hex_neighbors.f90 hex_neighbors.f90 sourcefile~honeyplots.f90->sourcefile~hex_neighbors.f90 sourcefile~xy_coordinates.f90 xy_coordinates.f90 sourcefile~honeyplots.f90->sourcefile~xy_coordinates.f90 sourcefile~xy_neighbors.f90 xy_neighbors.f90 sourcefile~honeyplots.f90->sourcefile~xy_neighbors.f90 sourcefile~hex_neighbors.f90->sourcefile~hex_coordinates.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_coordinates.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_layout.f90 sourcefile~xy_neighbors.f90->sourcefile~hex_layout.f90 sourcefile~xy_neighbors.f90->sourcefile~xy_coordinates.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules honeyplots Source Code honeyplots.f90 Source Code module honeyplots !! Providing plotting facilities for hex tessellations use pyplot_module use ogpf use hex_coordinates use hex_layout use hex_neighbors use xy_coordinates use xy_neighbors implicit none private public :: xy_plot , hex_plot , plot integer , parameter :: N = 6 ! Number of vertices in a hexagon interface plot procedure :: xy_plot procedure :: hex_plot end interface contains subroutine xy_plot ( lattice , nn_mask , nnn_mask , backend , figure_name , script_name , set_terminal ) !! >>> CURRENTLY GNUPLOT DOES NOT SUPPORT NN AND NNN LINKS, HELP IS WELCOME! !! Simple plotter for class(xy_lattice) objects. If optional argument nn_mask !! is passed it draws the nearest-neighbor bonds too. Similarly, if optional !! argument nnn_mask is passed a dashed link to next-nearest neighbors would !! be drawed. Otherwise only lallice sites. It features two backends, giving !! access to either matplotlib(pyplot) or gnuplot internal machinery. Either !! library needs to be installed in your system for hex_plot to work. !! You can specify a figure_name to save the plot to disk. If not specified !! the plot would be just displayed in a popup window (or the terminal with !! suitable configuration of the gnuplot backend) and a corresponding script !! saved, aiming at fast reproduction (the script will all contain data). !! The script has a default name (hex_plot.{py,gp}), but you can optionally !! give your own custom string, do not forget the appropriate file extension. !! Regarding output formats instead, the two backends have slightly different !! behavior: pyplot would infer the format from the given file extension in !! figure_name, whilst gnuplot does need a proper \"output terminal\" to be set. !! You can do that by passing the optional set_parameter variable. Refer to !! original gnuplot documentation for the list of available terminals and how !! they should be chosen. For convenience we report that you can get the list !! of (system dependent) available terminals in your console by executing the !! gnuplot -e \"set terminal\" command in your shell. Furthermore all systems !! should be compatible with the \"dumb\" terminal option, which would direct !! the plot to the terminal itself, in the form of ASCII art. This can be !! very useful for HPC workflows. type ( xy_lattice ), intent ( in ) :: lattice logical , allocatable , intent ( in ), optional :: nn_mask (:,:) logical , allocatable , intent ( in ), optional :: nnn_mask (:,:) character ( * ), intent ( in ), optional :: backend !! default: \"pyplot\" (or \"gnuplot\") character ( * ), intent ( in ), optional :: figure_name character ( * ), intent ( in ), optional :: script_name character ( * ), intent ( in ), optional :: set_terminal !! relevant to gnuplot backend type ( xy_lattice ) :: sublattice character ( 8 ) :: engine character ( 32 ) :: source_name real ( 8 ), allocatable :: Ax (:), Ay (:) real ( 8 ), allocatable :: Bx (:), By (:) real ( 8 ), dimension ( 2 ) :: x , y , x1 , y1 , x2 , y2 type ( pyplot ) :: plt type ( gpf ) :: gnu integer :: i , j , k , l sublattice = get_sublattice ( lattice , \"A\" ) Ax = sublattice % site % x Ay = sublattice % site % y sublattice = get_sublattice ( lattice , \"B\" ) Bx = sublattice % site % x By = sublattice % site % y if ( present ( backend )) then engine = trim ( backend ) else engine = \"pyplot\" end if select case ( trim ( engine )) case default print * , \"unknown backend: no plot generated\" case ( \"pyplot\" ) call plt % initialize ( xlabel = 'x' , ylabel = 'y' , axis_equal = . true .) ! Nearest Neighbor Links if ( present ( nn_mask )) then do i = 1 , size ( nn_mask , 1 ) do j = 1 , size ( nn_mask , 1 ) if ( nn_mask ( i , j )) then x ( 1 ) = lattice % site ( i )% x x ( 2 ) = lattice % site ( j )% x y ( 1 ) = lattice % site ( i )% y y ( 2 ) = lattice % site ( j )% y call plt % add_plot ( x , y , label = '' , linestyle = '-k' , linewidth = 2 ) endif enddo enddo endif ! Next Nearest Neighbors if ( present ( nnn_mask )) then do i = 1 , size ( nnn_mask , 1 ) do j = 1 , size ( nnn_mask , 1 ) if ( nnn_mask ( i , j )) then x ( 1 ) = lattice % site ( i )% x x ( 2 ) = lattice % site ( j )% x y ( 1 ) = lattice % site ( i )% y y ( 2 ) = lattice % site ( j )% y call plt % add_plot ( x , y , label = '' , linestyle = ':k' , linewidth = 1 ) endif enddo enddo endif ! Sublattice \"A\" call plt % add_plot ( Ax , Ay , label = '' , linestyle = 'o' , markersize = 5 ) ! Sublattice \"B call plt % add_plot ( Bx , By , label = '' , linestyle = 'o' , markersize = 5 ) if ( present ( script_name )) then source_name = script_name else source_name = \"hex_plot.py\" endif if ( present ( figure_name )) then call plt % savefig ( trim ( figure_name ), pyfile = trim ( source_name )) print * print * , \"> PyPlot figure saved to: \" // trim ( figure_name ) print * else print * print * , \"> PyPlot GUI popping up...\" print * call plt % showfig ( pyfile = trim ( source_name )) endif case ( \"gnuplot\" ) if ( present ( script_name )) then source_name = script_name else source_name = \"hex_plot.gp\" endif if ( present ( set_terminal )) then call gnu % options ( \"set term \" // set_terminal // \";\" ) else call gnu % options ( \"set term qt;\" ) endif if ( present ( figure_name )) then call gnu % options ( 'set output \"' // figure_name // '\"' ) endif call gnu % options ( \"set size ratio -1;\" ) ! --> axis equal call gnu % options ( \"unset grid\" ) ! --> grid off call gnu % xlabel ( 'x' ) call gnu % ylabel ( 'y' ) call gnu % filename ( source_name ) print * print * , \"> Gnuplot GUI popping up...\" print * call gnu % plot ( & x1 = Ax , y1 = Ay , & ls1 = 'with points pt 7 ps 1 lc rgb \"#1F77B4\"' , & x2 = Bx , y2 = By , & ls2 = 'with points pt 7 ps 1 lc rgb \"#FF7F0E\"' & ) end select end subroutine xy_plot subroutine hex_plot ( layout , hexagons , backend , figure_name , script_name , set_terminal ) !! Simple plotter for arrays of type(hex). It features two backends, giving !! access to either matplotlib(pyplot) or gnuplot internal machinery. Either !! library needs to be installed in your system for hex_plot to work. !! You can specify a figure_name to save the plot to disk. If not specified !! the plot would be just displayed in a popup window (or the terminal with !! suitable configuration of the gnuplot backend) and a corresponding script !! saved, aiming at fast reproduction (the script will all contain data). !! The script has a default name (hex_plot.{py,gp}), but you can optionally !! give your own custom string, do not forget the appropriate file extension. !! Regarding output formats instead, the two backends have slightly different !! behavior: pyplot would infer the format from the given file extension in !! figure_name, whilst gnuplot does need a proper \"output terminal\" to be set. !! You can do that by passing the optional set_parameter variable. Refer to !! original gnuplot documentation for the list of available terminals and how !! they should be chosen. For convenience we report that you can get the list !! of (system dependent) available terminals in your console by executing the !! gnuplot -e \"set terminal\" command in your shell. Furthermore all systems !! should be compatible with the \"dumb\" terminal option, which would direct !! the plot to the terminal itself, in the form of ASCII art. This can be !! very useful for HPC workflows. type ( unit_cell ), intent ( in ) :: layout type ( hex ), intent ( in ) :: hexagons (:) character ( * ), intent ( in ), optional :: backend !! default: \"pyplot\" (or \"gnuplot\") character ( * ), intent ( in ), optional :: figure_name character ( * ), intent ( in ), optional :: script_name character ( * ), intent ( in ), optional :: set_terminal !! relevant to gnuplot backend character ( 8 ) :: engine character ( 32 ) :: source_name integer :: M type ( pyplot ) :: plt type ( gpf ) :: gnu type ( xy_lattice ), allocatable :: corner (:) real ( 8 ), dimension ( N ) :: xtmp , ytmp real ( 8 ), allocatable :: x (:), y (:) integer :: i , j M = size ( hexagons ) allocate ( x ( N * M ), y ( N * M ), corner ( M )) corner = hex2corner ( layout , hexagons ) do i = 1 , M do j = 1 , N xtmp ( j ) = corner ( i )% site ( j )% x ytmp ( j ) = corner ( i )% site ( j )% y enddo x (( 1 + N * ( i - 1 )): N * i ) = xtmp y (( 1 + N * ( i - 1 )): N * i ) = ytmp enddo if ( present ( backend )) then engine = trim ( backend ) else engine = \"pyplot\" end if select case ( trim ( engine )) case default print * , \"unknown backend: no plot generated\" case ( \"pyplot\" ) call plt % initialize ( xlabel = 'x' , ylabel = 'y' , axis_equal = . true .) call plt % add_plot ( x , y , label = '' , linestyle = 'o' , markersize = 5 ) if ( present ( script_name )) then source_name = script_name else source_name = \"hex_plot.py\" endif if ( present ( figure_name )) then call plt % savefig ( trim ( figure_name ), pyfile = trim ( source_name )) print * print * , \"> PyPlot figure saved to: \" // trim ( figure_name ) print * else print * print * , \"> PyPlot GUI popping up...\" print * call plt % showfig ( pyfile = trim ( source_name )) endif case ( \"gnuplot\" ) if ( present ( script_name )) then source_name = script_name else source_name = \"hex_plot.gp\" endif if ( present ( set_terminal )) then call gnu % options ( \"set term \" // set_terminal // \";\" ) else call gnu % options ( \"set term qt;\" ) endif if ( present ( figure_name )) then call gnu % options ( 'set output \"' // figure_name // '\"' ) endif call gnu % options ( \"set size ratio -1;\" ) ! --> axis equal call gnu % options ( \"unset grid\" ) ! --> grid off call gnu % xlabel ( 'x' ) call gnu % ylabel ( 'y' ) call gnu % filename ( source_name ) print * print * , \"> Gnuplot GUI popping up...\" print * call gnu % plot ( x , y , 'with points pt 7 ps 1 lc rgb \"#1F77B4\"' ) end select end subroutine hex_plot end module honeyplots","tags":"","loc":"sourcefile/honeyplots.f90.html"},{"title":"hex_geometries.f90 – HoneyTools","text":"This file depends on sourcefile~~hex_geometries.f90~~EfferentGraph sourcefile~hex_geometries.f90 hex_geometries.f90 sourcefile~hex_coordinates.f90 hex_coordinates.f90 sourcefile~hex_geometries.f90->sourcefile~hex_coordinates.f90 sourcefile~hex_layout.f90 hex_layout.f90 sourcefile~hex_geometries.f90->sourcefile~hex_layout.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~hex_geometries.f90~~AfferentGraph sourcefile~hex_geometries.f90 hex_geometries.f90 sourcefile~honeytools.f90 honeytools.f90 sourcefile~honeytools.f90->sourcefile~hex_geometries.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules hex_geometries Source Code hex_geometries.f90 Source Code module hex_geometries !! Provide common honeycomb geometries, as dynamic type(hex) arrays use hex_coordinates use hex_layout use assert_m , only : assert ![pure assertion for triangle] implicit none private public :: hex_insert ! utility to grow hex arrays public :: hex_supercell , hex_triangle , hex_flake public :: hex_armchair_stripe , hex_zigzag_stripe public :: hex_line ! to \"draw\" lines in hex space contains ! PUBLIC API [private at bottom] pure function hex_supercell ( rows , cols ) result ( hexagons ) !! Build a honeycomb supercell (parallelogram) integer , intent ( in ) :: rows , cols type ( hex ) :: hexagons ( rows * cols ) integer :: i , j , k k = 0 do i = 1 , rows do j = 1 , cols k = k + 1 hexagons ( k ) = hex ( q = i , r = j ) enddo enddo end function hex_supercell pure function hex_triangle ( size ) result ( hexagons ) !! Build a triangle-shaped honeycomb flake integer , intent ( in ) :: size type ( hex ), allocatable :: hexagons (:) integer :: i , j call assert ( size > 1 , \"triangle size > 1\" , size ) do i = 0 , size do j = 0 , size - i call hex_insert ( hexagons , hex ( i , j )) enddo enddo end function hex_triangle pure function hex_flake ( radius ) result ( hexagons ) !! Build a hexagon-shaped honeycomb flake integer , intent ( in ) :: radius type ( hex ), allocatable :: hexagons (:) integer :: i , j do i = - radius , + radius do j = max ( - radius , - i - radius ), min ( radius , - i + radius ) call hex_insert ( hexagons , hex ( i , j )) enddo enddo end function hex_flake pure function hex_armchair_stripe ( height , width ) result ( hexagons ) !! Build a armchair-on-top honeycomb stripe/ribbon !! CONVERSION TO XY SITES REQUIRES ARMCHAIR LAYOUT integer , intent ( in ) :: height , width type ( hex ), allocatable :: hexagons (:) integer :: i , j , offset do i = 1 , width offset = floor ( i / 2.d0 ) do j = 1 - offset , height - offset call hex_insert ( hexagons , hex ( i , j )) enddo enddo end function hex_armchair_stripe pure function hex_zigzag_stripe ( height , width ) result ( hexagons ) !! Build a zigzag-on-top honeycomb stripe/ribbon !! CONVERSION TO XY SITES REQUIRES ZIGZAG LAYOUT integer , intent ( in ) :: height , width type ( hex ), allocatable :: hexagons (:) integer :: i , j , offset do i = 1 , height offset = floor ( i / 2.d0 ) do j = 1 - offset , width - offset call hex_insert ( hexagons , hex ( i , j )) enddo enddo end function hex_zigzag_stripe pure function hex_line ( A , B ) result ( line ) !! Draw a line between A and B, in hex space type ( hex ), intent ( in ) :: A , B type ( hex ), allocatable :: line (:) real ( 8 ), dimension ( 3 ) :: lntrp integer , dimension ( 3 ) :: ai , bi real ( 8 ), dimension ( 3 ) :: ar , br real ( 8 ) :: step integer :: dist , i dist = hex_distance ( A , B ) step = 1 d0 / max ( dist , 1 ) ! handle A==B :) do i = 0 , dist ! Unpack ai = [ A % q , A % r , A % s ] bi = [ B % q , B % r , B % s ] ! Cast ar = real ( ai , 8 ) br = real ( bi , 8 ) ! Nudge ar ( 1 : 2 ) = ar ( 1 : 2 ) + 1 d - 6 ar ( 3 ) = ar ( 3 ) - 2 d - 6 br ( 1 : 2 ) = br ( 1 : 2 ) + 1 d - 6 br ( 3 ) = br ( 3 ) - 2 d - 6 ! Interpolate lntrp = linear_interpolation ( ar , br , step * i ) ! Grow the vect call hex_insert ( line , hex_round ( lntrp )) enddo end function hex_line pure subroutine hex_insert ( vec , val ) !! Utility to grow type(hex) arrays, it is a !! poor man implementation of a dynamic array !! insertion, a là std::vector (but with no !! preallocation and smart doubling...) type ( hex ), intent ( inout ), allocatable :: vec (:) type ( hex ), intent ( in ) :: val type ( hex ), allocatable :: tmp (:) integer :: len if ( allocated ( vec )) then len = size ( vec ) allocate ( tmp ( len + 1 )) tmp (: len ) = vec call move_alloc ( tmp , vec ) len = len + 1 else len = 1 allocate ( vec ( len )) end if ! Insert val at back vec ( len ) = val end subroutine hex_insert ! THESE ARE PRIVATE NAMES pure elemental function linear_interpolation ( a , b , t ) result ( l ) !! Linear interpolation from a to b, with step t !! a + (b - a) * t = a * (1-t) + b * t !! for better floating-point precision real ( 8 ), intent ( in ) :: a , b , t real ( 8 ) :: l l = a * ( 1 - t ) + b * t end function linear_interpolation pure function hex_round ( xyz ) result ( qrs ) !! Round a triplet of reals to a proper hex object !! > this needs to preserve the q+r+s==0 condition real ( 8 ), intent ( in ) :: xyz ( 3 ) type ( hex ) :: qrs real ( 8 ) :: x , y , z integer :: q , r , s real ( 8 ) :: dq , dr , ds ! Unpack x = xyz ( 1 ) y = xyz ( 2 ) z = xyz ( 3 ) ! Round xyz q = nint ( x ) r = nint ( y ) s = nint ( z ) ! Eval diffs dq = abs ( x - q ) dr = abs ( x - r ) ds = abs ( x - s ) ! Reset bigger diff if ( dq > dr . and . dq > ds ) then q = - r - s elseif ( dr > ds ) then r = - q - s else s = - q - r endif ! Repack qrs = hex ( q , r , s ) ! internal assertion :) end function hex_round end module hex_geometries","tags":"","loc":"sourcefile/hex_geometries.f90.html"},{"title":"xy_coordinates.f90 – HoneyTools","text":"This file depends on sourcefile~~xy_coordinates.f90~~EfferentGraph sourcefile~xy_coordinates.f90 xy_coordinates.f90 sourcefile~hex_coordinates.f90 hex_coordinates.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_coordinates.f90 sourcefile~hex_layout.f90 hex_layout.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_layout.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~xy_coordinates.f90~~AfferentGraph sourcefile~xy_coordinates.f90 xy_coordinates.f90 sourcefile~honeyplots.f90 honeyplots.f90 sourcefile~honeyplots.f90->sourcefile~xy_coordinates.f90 sourcefile~xy_neighbors.f90 xy_neighbors.f90 sourcefile~honeyplots.f90->sourcefile~xy_neighbors.f90 sourcefile~honeytools.f90 honeytools.f90 sourcefile~honeytools.f90->sourcefile~xy_coordinates.f90 sourcefile~honeytools.f90->sourcefile~xy_neighbors.f90 sourcefile~xy_neighbors.f90->sourcefile~xy_coordinates.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules xy_coordinates Source Code xy_coordinates.f90 Source Code module xy_coordinates !! Defining real space 2D coordinates for honeycomb lattice sites use hex_coordinates use hex_layout use assert_m , only : assert ![pure assertion] implicit none private public :: xy , xy_site , xy_lattice ! xy class hyerarchy public :: xy_distance , xy_print , xy_ordered_union ! xy-bound procedures public :: hex2center , hex2corner , hex2site , hex2lattice ! hex-2-xy procedures public :: get_sublattice ! xy_lattice utility integer , parameter :: N = 6 ! Number of vertices in a hexagon real ( 8 ), parameter :: PI = 4 d0 * atan ( 1 d0 ) ! π to selected kind type xy !! Base type for 2D points real ( 8 ) :: x real ( 8 ) :: y contains generic :: operator ( == ) => eq_xy generic :: operator ( /= ) => neq_xy procedure , private :: eq_xy procedure , private :: neq_xy end type type , extends ( xy ) :: xy_site !! A 2D point extension for inequivalent sites character ( 1 ) :: label !! A or B (sublattice) integer :: key = 0 !! for lattice lookup end type type xy_lattice !! Wrapper type for storing dynamically !! sized collections of lattice sites type ( xy_site ), allocatable :: site (:) integer :: size contains generic :: operator ( == ) => eq_lattice generic :: operator ( /= ) => neq_lattice procedure , private :: eq_lattice procedure , private :: neq_lattice procedure :: push_back end type interface xy_print procedure :: xy_class_print procedure :: xy_lattice_print end interface contains ! PUBLIC API [private at bottom] pure elemental function xy_distance ( A , B ) result ( d ) !! Polymorphic euclidean distance for xy class class ( xy ), intent ( in ) :: A , B type ( xy ) :: C real ( 8 ) :: d C % x = A % x - B % x C % y = A % y - B % y d = xy_norm ( C ) end function pure elemental function hex2site ( layout , H , label ) result ( site ) !! Convert hex coordinates to real 2D lattice sites !! [returning the xy coordinates for the unique unit-cell, !!  sites \"A\" and \"B\": this of course does not account for !!  border effects, so would be suitable only for simple, !!  periodized, systems, which for now are out of scope.] !! Actual real-space layout has to be specified by passing !! a (scalar) unit_cell object. type ( unit_cell ), intent ( in ) :: layout type ( hex ), intent ( in ) :: H character ( 1 ), intent ( in ) :: label !! A or B type ( xy ) :: center type ( xy ) :: offset type ( xy_site ) :: site center = hex2center ( layout , H ) select case ( label ) case ( \"A\" ) offset = ith_corner_offset ( layout , i = 1 ) case ( \"B\" ) offset = ith_corner_offset ( layout , i = 2 ) case default error stop \"Honeycomb sites must have 'A' or 'B' label\" end select site % x = center % x + offset % x site % y = center % y + offset % y end function pure elemental function hex2corner ( layout , H ) result ( corner ) !! Convert hex coordinates to real 2D space !! [returning the xy coordinates for the hexagon corners, !!  as appropriatiely wrapped in the \"xy_lattice\" type] !! Actual real-space layout has to be specified by passing !! a (scalar) unit_cell object. type ( unit_cell ), intent ( in ) :: layout type ( hex ), intent ( in ) :: H type ( xy ) :: center type ( xy ) :: offset type ( xy_lattice ) :: corner integer :: i center = hex2center ( layout , H ) allocate ( corner % site ( N )) corner % size = N do i = 1 , N offset = ith_corner_offset ( layout , i ) corner % site ( i )% x = center % x + offset % x corner % site ( i )% y = center % y + offset % y if ( modulo ( i , 2 ) == 1 ) then corner % site ( i )% label = \"A\" else corner % site ( i )% label = \"B\" endif corner % site ( i )% key = i enddo end function pure elemental function hex2center ( layout , H ) result ( center ) !! Convert hex coordinates to real 2D space !! [returning the xy coordinates of the hexagon center] !! Actual real-space layout has to be specified by passing !! a (scalar) unit_cell object. type ( unit_cell ), intent ( in ) :: layout type ( hex ), intent ( in ) :: H type ( xy ) :: center type ( hex_orientation ) :: basis ! Project [q,r] along unit-cell basis to get [x,y] basis = layout % orientation center % x = basis % uq ( 1 ) * H % q + basis % ur ( 1 ) * H % r ! mixed math ok center % y = basis % uq ( 2 ) * H % q + basis % ur ( 2 ) * H % r ! mixed math ok ! Rescale and recenter according to unit-cell data center % x = center % x * layout % size + layout % origin ( 1 ) center % y = center % y * layout % size + layout % origin ( 2 ) ! Equivalent to: !        ⎡x⎤   ⎡uq(1)  ur(1)⎤   ⎡q⎤ !        ⎥ ⎥ = ⎥            ⎥ × ⎥ ⎥ × size + origin !        ⎣y⎦   ⎣uq(2)  ur(2)⎦   ⎣r⎦ end function pure function hex2lattice ( layout , hexagons ) result ( lattice ) !! Generate a type(xy_lattice) object from any given hex !! array, provided a suitable layout (unit-cell) type ( unit_cell ), intent ( in ) :: layout type ( hex ), intent ( in ) :: hexagons (:) type ( xy_lattice ) :: corners ( size ( hexagons )) type ( xy_lattice ) :: lattice integer :: i corners = hex2corner ( layout , hexagons ) if ( size ( corners ) == 1 ) then lattice = corners ( 1 ) return endif lattice = xy_ordered_union ( corners ( 1 ), corners ( 2 )) do i = 3 , size ( hexagons ) lattice = xy_ordered_union ( lattice , corners ( i )) enddo end function pure elemental function get_sublattice ( lattice , label ) result ( sublattice ) !! Extract sublattice, given a lattice and a label (\"A\" or \"B\") type ( xy_lattice ), intent ( in ) :: lattice character ( 1 ), intent ( in ) :: label !! A or B type ( xy_lattice ) :: sublattice associate ( sites => lattice % site ) sublattice % site = pack ( sites , sites % label == label ) end associate end function pure function xy_ordered_union ( A , B ) result ( C ) !! An ordered-keys set union for xy_lattices. !! It compares the lattice sites, looking at !! their x and y coordinates only: equal x,y !! entries are inserted in C just once, so to !! make it a set. A and B must be sets too. !! The sublattice labels are preserved in the !! process, assuming that two sites with the !! same x,y pertain to the same sublattice. !! For A the keys are assumed to be 1:size(A), !! and preserved as such (with an assertion). !! The keys of B are instead discarded, so to !! be replaced by size(A):size(C), which thus !! amounts to have result C uniquely indexed !! as 1, 2, ... , size(A) + size(B). !! This allows building consistently indexed !! matrices to act on the lattice array, such !! as real-space tight-binding hamiltonians. !! The keys would then be used to index other !! real space quantities, such as LDOS, Chern !! marker, local magnetization, and so on. type ( xy_lattice ), intent ( in ) :: A type ( xy_lattice ), intent ( in ) :: B type ( xy_lattice ) :: C integer :: i , j C = A !copy all data of A into C do j = 1 , size ( A % site ) if ( C % site ( j )% key /= j ) then C % site ( j )% key = j endif enddo do i = 1 , size ( B % site ) if ( all ( B % site ( i ) /= A % site )) then call C % push_back ( B % site ( i )) j = size ( C % site ) C % site ( j )% key = j endif enddo ! What if we allocate to (size(A)+size(B)) ! memory to C, fill in the unique elements ! and then just truncate to the correct size ! by just calling pack(C,C/=0)? Assuming of ! course that C has been initialized to 0d0. ! Would it perform better than dynamically ! growing the array at each insertion? 0ˆ0-, end function ! THESE ARE PRIVATE NAMES pure function ith_corner_offset ( layout , i ) result ( offset ) !! Compute the i-th offset vector connecting the hexagon center !! to its corners, returning a (scalar) xy coordinate type ( unit_cell ), intent ( in ) :: layout integer , intent ( in ) :: i type ( xy ) :: offset real ( 8 ) :: angle angle = 2 d0 * PI / N * ( layout % orientation % angle + i ) ! mixed math ok offset = xy ( x = layout % size * cos ( angle ), y = layout % size * sin ( angle )) end function pure elemental function eq_xy ( A , B ) result ( isequal ) !! tolerance equality for xy class !! [absolute tol hard-coded to 1d-12] !! -> probably to improve... class ( xy ), intent ( in ) :: A , B logical :: isequal isequal = abs ( A % x - B % x ) < 1 d - 12 isequal = abs ( A % y - B % y ) < 1 d - 12 . and . isequal end function pure elemental function neq_xy ( A , B ) result ( notequal ) !! tolerance inequality for xy class !! [absolute tol hard-coded to 1d-12] !! -> probably to improve... class ( xy ), intent ( in ) :: A , B logical :: notequal notequal = . not .( eq_xy ( A , B )) end function pure elemental function eq_lattice ( A , B ) result ( isequal ) !! polymorphic equality overload for xy_lattice type class ( xy_lattice ), intent ( in ) :: A , B logical :: isequal isequal = all ( eq_xy ( A % site , B % site )) end function pure elemental function neq_lattice ( A , B ) result ( notequal ) !! polymorphic inequality overload for xy_lattice type class ( xy_lattice ), intent ( in ) :: A , B logical :: notequal notequal = . not .( eq_lattice ( A , B )) end function pure elemental function xy_norm ( A ) result ( r ) !! polymorphic euclidean norm for xy class class ( xy ), intent ( in ) :: A real ( 8 ) :: r r = sqrt ( A % x ** 2 + A % y ** 2 ) end function pure subroutine push_back ( vec , val ) !! Poor man implementation of a dynamic !! array, a là std::vector (but without !! preallocation and smart doubling...) class ( xy_lattice ), intent ( inout ) :: vec type ( xy_site ), intent ( in ) :: val type ( xy_site ), allocatable :: tmp (:) integer :: len if ( allocated ( vec % site )) then len = size ( vec % site ) allocate ( tmp ( len + 1 )) tmp (: len ) = vec % site call move_alloc ( tmp , vec % site ) len = len + 1 else len = 1 allocate ( vec % site ( len )) end if !PUSH val at the BACK vec % site ( len ) = val !Increade formal size vec % size = len end subroutine push_back impure elemental subroutine xy_class_print ( S , unit , quiet ) !! Pretty print of xy coordinates in static arrays class ( xy ), intent ( in ) :: S integer , intent ( in ), optional :: unit !! default = $stdout logical , intent ( in ), optional :: quiet !! default = .false. integer :: stdunit logical :: verbose if ( present ( quiet )) then verbose = . not . quiet else verbose = . true . endif if ( present ( unit )) then stdunit = unit else stdunit = 6 ! stdout endif if ( verbose ) then select type ( S ) type is ( xy_site ) write ( stdunit , * ) \"site #\" , S % key , \"[x,y]: \" , S % x , S % y class default write ( stdunit , * ) \"real-space coordinates [x,y]: \" , S % x , S % y end select else write ( stdunit , * ) S % x , S % y endif end subroutine impure elemental subroutine xy_lattice_print ( S , unit , quiet ) !! Pretty print of xy coordinates in dynamic arrays type ( xy_lattice ), intent ( in ) :: S integer , intent ( in ), optional :: unit !! default = $stdout logical , intent ( in ), optional :: quiet !! default = .false. type ( xy_site ) :: vector ( size ( S % site )) integer :: stdunit logical :: verbose integer :: i if ( present ( quiet )) then verbose = . not . quiet else verbose = . true . endif if ( present ( unit )) then stdunit = unit else stdunit = 6 ! stdout endif vector = S % site do i = 1 , size ( vector ) call xy_print ( vector ( i ), unit = stdunit , quiet = . not . verbose ) enddo end subroutine end module xy_coordinates","tags":"","loc":"sourcefile/xy_coordinates.f90.html"},{"title":"honeytools.f90 – HoneyTools","text":"This file depends on sourcefile~~honeytools.f90~~EfferentGraph sourcefile~honeytools.f90 honeytools.f90 sourcefile~hex_coordinates.f90 hex_coordinates.f90 sourcefile~honeytools.f90->sourcefile~hex_coordinates.f90 sourcefile~hex_geometries.f90 hex_geometries.f90 sourcefile~honeytools.f90->sourcefile~hex_geometries.f90 sourcefile~hex_layout.f90 hex_layout.f90 sourcefile~honeytools.f90->sourcefile~hex_layout.f90 sourcefile~hex_neighbors.f90 hex_neighbors.f90 sourcefile~honeytools.f90->sourcefile~hex_neighbors.f90 sourcefile~xy_coordinates.f90 xy_coordinates.f90 sourcefile~honeytools.f90->sourcefile~xy_coordinates.f90 sourcefile~xy_neighbors.f90 xy_neighbors.f90 sourcefile~honeytools.f90->sourcefile~xy_neighbors.f90 sourcefile~hex_geometries.f90->sourcefile~hex_coordinates.f90 sourcefile~hex_geometries.f90->sourcefile~hex_layout.f90 sourcefile~hex_neighbors.f90->sourcefile~hex_coordinates.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_coordinates.f90 sourcefile~xy_coordinates.f90->sourcefile~hex_layout.f90 sourcefile~xy_neighbors.f90->sourcefile~hex_layout.f90 sourcefile~xy_neighbors.f90->sourcefile~xy_coordinates.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules honeytools Source Code honeytools.f90 Source Code module honeytools !! Top level API: what you probably want to use use hex_coordinates use hex_layout use hex_neighbors use hex_geometries use xy_coordinates use xy_neighbors implicit none private public :: xy_site , xy_lattice , xy_print , xy_shells , xy_nn_hop , xy_nnn_hop public :: xy_nearest_neighbors , xy_next_nearest_neighbors public :: unit_cell , hex_orientation , armchair , zigzag ! to generate layouts public :: get_supercell , get_triangle , get_flake , get_stripe , get_sublattice contains pure function get_supercell ( rows , cols , layout ) & result ( lattice ) !! Get the lattice for a honeycomb supercell integer , intent ( in ) :: rows , cols type ( unit_cell ), intent ( in ) :: layout type ( xy_lattice ) :: lattice type ( hex ), dimension ( rows * cols ) :: hexagons hexagons = hex_supercell ( rows , cols ) lattice = hex2lattice ( layout , hexagons ) end function pure function get_triangle ( size , layout ) & result ( lattice ) !! Get the lattice for a triangle-shaped flake integer , intent ( in ) :: size type ( unit_cell ), intent ( in ) :: layout type ( xy_lattice ) :: lattice type ( hex ), allocatable :: hexagons (:) hexagons = hex_triangle ( size ) lattice = hex2lattice ( layout , hexagons ) end function pure function get_flake ( radius , layout ) & result ( lattice ) !! Get the lattice for a hexagon-shaped flake integer , intent ( in ) :: radius type ( unit_cell ), intent ( in ) :: layout type ( xy_lattice ) :: lattice type ( hex ), allocatable :: hexagons (:) hexagons = hex_flake ( radius ) lattice = hex2lattice ( layout , hexagons ) end function pure function get_stripe ( height , width , layout ) & result ( lattice ) !! Get the lattice for a hexagon-shaped flake integer , intent ( in ) :: height , width type ( unit_cell ), intent ( in ) :: layout type ( xy_lattice ) :: lattice type ( hex ), allocatable :: hexagons (:) associate ( cell => layout % orientation ) if ( cell == armchair ) then hexagons = hex_armchair_stripe ( height , width ) elseif ( cell == zigzag ) then hexagons = hex_zigzag_stripe ( height , width ) else endif lattice = hex2lattice ( layout , hexagons ) end associate end function end module honeytools","tags":"","loc":"sourcefile/honeytools.f90.html"}]}